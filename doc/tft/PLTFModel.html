<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of PLTFModel</title>
  <meta name="keywords" content="PLTFModel">
  <meta name="description" content="Represents data required to describe a tensor factorization model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html tft -->
<h1>PLTFModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Represents data required to describe a tensor factorization model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Represents data required to describe a tensor factorization model

   A model is represented with its name and factors array of
   TFFactor objects. dims array of TFDimension objects define
   dimensions used by this model. Dimensions are transfered to C++
   in the order defined in dims array. See examples below for a
   full model description.

   Examples:
   
   dim_i = TFDimension('name', 'i', 'cardinality', 5);
   dim_j = TFDimension('cardinality', 6, 'name', 'j');
   dim_k = TFDimension('cardinality', 7, 'name', 'k');
   dim_r = TFDimension('cardinality', 10, 'name', 'r');
   
   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);
   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);
   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);
   
   parafac_model = PLTFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);
   
   parafac_model.rand_init_latent_factors('all');

   See also <a href="TFDimension.html" class="code" title="">TFDimension</a>, <a href="TFFactor.html" class="code" title="">TFFactor</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="GTMGraph.html" class="code" title="">GTMGraph</a>	Represents a graph of PLTFModel objects.</li><li><a href="PLTFModel.html" class="code" title="">PLTFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFDimension.html" class="code" title="">TFDimension</a>	Represents a single dimension</li><li><a href="TFFactor.html" class="code" title="">TFFactor</a>	Represents a PLTF factor</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="GCTFModel.html" class="code" title="">GCTFModel</a>	Represents data required to describe a GCTF model</li><li><a href="GTMGraph.html" class="code" title="">GTMGraph</a>	Represents a graph of PLTFModel objects.</li><li><a href="PLTFModel.html" class="code" title="">PLTFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = PLTFModel(varargin)</a></li><li><a href="#_sub2" class="code">function [] = pltf_optimal_dot(obj, filename)</a></li><li><a href="#_sub3" class="code">function [ dot_data ] = pltf(obj, iternum, contract_type,</a></li><li><a href="#_sub4" class="code">function [ kl cost dot_data ] = pltf_iteration(obj,</a></li><li><a href="#_sub5" class="code">function [ dot_data cost ] = delta(obj, alpha,</a></li><li><a href="#_sub6" class="code">function [graph] = schedule_dp(obj)</a></li><li><a href="#_sub7" class="code">function [newmodel ] = contract_all(obj, contract_type,</a></li><li><a href="#_sub8" class="code">function [newmodel] = contract_full(obj, operation_type,</a></li><li><a href="#_sub9" class="code">function [newmodel] = contract(obj, dim, operation_type,</a></li><li><a href="#_sub10" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj,</a></li><li><a href="#_sub11" class="code">function [obj] = update_cost_from_temp(obj)</a></li><li><a href="#_sub12" class="code">function [obj] = update_cost_from_latent(obj)</a></li><li><a href="#_sub13" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a></li><li><a href="#_sub14" class="code">function [size] = get_element_size(obj)</a></li><li><a href="#_sub15" class="code">function [card] = get_index_card(obj, index_char)</a></li><li><a href="#_sub16" class="code">function [factor] = get_first_non_observed_factor(obj)</a></li><li><a href="#_sub17" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a></li><li><a href="#_sub18" class="code">function [ind] = find_cell_char(obj, chars)</a></li><li><a href="#_sub19" class="code">function [r] = get_dimension_index(obj, dim)</a></li><li><a href="#_sub20" class="code">function [ordered_index_chars] = order_dims(obj,</a></li><li><a href="#_sub21" class="code">function [alldims] = get_all_used_dims(obj)</a></li><li><a href="#_sub22" class="code">function [contract_dims] = get_contraction_dims(obj)</a></li><li><a href="#_sub23" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a></li><li><a href="#_sub24" class="code">function [factor_inds] = latent_factor_indices(obj)</a></li><li><a href="#_sub25" class="code">function [factors] = latent_factors(obj)</a></li><li><a href="#_sub26" class="code">function [factor_ind] = observed_factor_index(obj)</a></li><li><a href="#_sub27" class="code">function [factor] = observed_factor(obj)</a></li><li><a href="#_sub28" class="code">function [factors] = observed_factors(obj)</a></li><li><a href="#_sub29" class="code">function [factors] = input_factors(obj)</a></li><li><a href="#_sub30" class="code">function [factors] = temp_factors(obj)</a></li><li><a href="#_sub31" class="code">function [index] = get_factor_index(obj, factor)</a></li><li><a href="#_sub32" class="code">function [name] = get_factor_data_name(obj, index)</a></li><li><a href="#_sub33" class="code">function [code_name] = get_coded_factor_name(obj, index)</a></li><li><a href="#_sub34" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a></li><li><a href="#_sub35" class="code">function [r] = eq(a,b)</a></li><li><a href="#_sub36" class="code">function [] = full_pltf_mem_analysis(obj)</a></li><li><a href="#_sub37" class="code">function [] = optimal_pltf_mem_analysis(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Represents data required to describe a tensor factorization model</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%   A model is represented with its name and factors array of</span>
0004 <span class="comment">%   TFFactor objects. dims array of TFDimension objects define</span>
0005 <span class="comment">%   dimensions used by this model. Dimensions are transfered to C++</span>
0006 <span class="comment">%   in the order defined in dims array. See examples below for a</span>
0007 <span class="comment">%   full model description.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   Examples:</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   dim_i = TFDimension('name', 'i', 'cardinality', 5);</span>
0012 <span class="comment">%   dim_j = TFDimension('cardinality', 6, 'name', 'j');</span>
0013 <span class="comment">%   dim_k = TFDimension('cardinality', 7, 'name', 'k');</span>
0014 <span class="comment">%   dim_r = TFDimension('cardinality', 10, 'name', 'r');</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);</span>
0017 <span class="comment">%   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);</span>
0018 <span class="comment">%   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   parafac_model = PLTFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%   parafac_model.rand_init_latent_factors('all');</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   See also TFDimension, TFFactor</span>
0025 
0026 classdef <a href="PLTFModel.html" class="code" title="">PLTFModel</a>
0027 
0028 
0029     properties
0030         name = <span class="string">''</span>;            <span class="comment">% name of the model</span>
0031         factors = [<a href="TFFactor.html" class="code" title="">TFFactor</a>]; <span class="comment">% array of TFFactor</span>
0032 
0033         dims = <a href="TFDimension.html" class="code" title="">TFDimension</a>; <span class="comment">% array of TFDimension used by factors defines</span>
0034                             <span class="comment">% order of dimensions on memory</span>
0035 
0036         cost = 0;
0037 
0038     <span class="keyword">end</span>
0039 
0040 
0041     methods
0042 
0043         <a name="_sub0" href="#_subfunctions" class="code">function obj = PLTFModel(varargin)</a>
0044             p = inputParser;
0045             addParamValue(p, <span class="string">'name'</span>, <span class="string">''</span>, @isstr);
0046             addParamValue(p, <span class="string">'factors'</span>, [], @isvector);
0047             addParamValue(p, <span class="string">'dims'</span>, [], @isvector);
0048 
0049             parse(p,varargin{:});
0050 
0051             <span class="comment">% check if all dims elements are TFDimension objects</span>
0052             <span class="keyword">for</span> i = 1:length(p.Results.dims)
0053                 <span class="keyword">if</span> ~isa(p.Results.dims(i), <span class="string">'TFDimension'</span>)
0054                     err = MException( <span class="keyword">...</span>
0055                         [<span class="string">'PLTFModel:DimensionNotTFDimension'</span>], <span class="keyword">...</span>
0056                         [<span class="string">'Dimensions of PLTFModel must be '</span> <span class="keyword">...</span>
0057                          <span class="string">'TFDimension objects'</span>]);
0058                     throw(err);
0059                 <span class="keyword">end</span>
0060             <span class="keyword">end</span>
0061             obj.dims = p.Results.dims;
0062 
0063             <span class="comment">% check if all factors are TFFactor objects</span>
0064             <span class="keyword">for</span> i = 1:length(p.Results.factors)
0065                 <span class="keyword">if</span> ~isa(p.Results.factors(i), <span class="string">'TFFactor'</span>)
0066                     err = MException( <span class="keyword">...</span>
0067                         [<span class="string">'PLTFModel:FactorsNotTFFactor'</span>], <span class="keyword">...</span>
0068                         [<span class="string">'Factors of PLTFModel must be '</span> <span class="keyword">...</span>
0069                          <span class="string">'TFFactor objects'</span>]);
0070                     throw(err);
0071                 <span class="keyword">end</span>
0072             <span class="keyword">end</span>
0073             obj.factors = p.Results.factors;
0074 
0075             obj.name = p.Results.name;
0076 
0077         <span class="keyword">end</span>
0078 
0079 
0080 
0081         <a name="_sub1" href="#_subfunctions" class="code">function [] = pltf_optimal_dot(obj, filename)</a>
0082         <span class="comment">% Calls PLTF function and collects output of print_dot from</span>
0083         <span class="comment">% each GTM operation and plots in a single graph</span>
0084             <span class="keyword">global</span> last_node_id;
0085             last_node_id = 1;
0086 
0087             dot_str = obj.pltf(1, <span class="string">'optimal'</span>, <span class="string">'mem_analysis'</span>, <span class="keyword">...</span>
0088                                <span class="string">'yes'</span>);
0089 
0090             str = [ <span class="string">'digraph structs{'</span> char(10) <span class="keyword">...</span>
0091                     <span class="string">'rankdir=LR;'</span> char(10) <span class="keyword">...</span>
0092                     <span class="string">'node [shape=plaintext];'</span> char(10) <span class="keyword">...</span>
0093                     <span class="string">'splines=false; '</span> char(10)];
0094             cmd = [ <span class="string">'echo '''</span> str char(10) dot_str <span class="keyword">...</span>
0095                     <span class="string">'}'' | dot -T svg '</span> ];
0096             <span class="keyword">if</span> nargin == 2
0097                 system([ cmd <span class="string">' -o '</span> filename ]);
0098             <span class="keyword">else</span>
0099                 system([ cmd <span class="string">' | display '</span> ]);
0100             <span class="keyword">end</span>
0101         <span class="keyword">end</span>
0102 
0103 
0104 
0105         <a name="_sub2" href="#_subfunctions" class="code">function [ dot_data ] = pltf(obj, iternum, contract_type, </a><span class="keyword">...</span>
0106                                      operation_type, <span class="keyword">...</span>
0107                                      return_dot_data)
0108         <span class="comment">% performs PLTF update operations on the model</span>
0109         <span class="comment">% returns estimated TFFactor (\hat(X))</span>
0110         <span class="comment">%</span>
0111         <span class="comment">% iternum: number of iterations</span>
0112         <span class="comment">%</span>
0113         <span class="comment">% contract_type: if equals to 'optimal', contractions are</span>
0114         <span class="comment">% performed in least memory using sequence defines order of</span>
0115         <span class="comment">% contraction operations, if equals to 'full', full tensor</span>
0116         <span class="comment">% is used for contraction operations instead of generating</span>
0117         <span class="comment">% temporary factors.</span>
0118         <span class="comment">%</span>
0119         <span class="comment">% operation_type: if equals to 'compute' normal contraction</span>
0120         <span class="comment">% operations are performed. if equals to 'mem_analysis'</span>
0121         <span class="comment">% operation are not performed but memory requirement is</span>
0122         <span class="comment">% calculated and reported. In 'mem_analysis' mode iternum</span>
0123         <span class="comment">% argument is not considered only a single iteration is</span>
0124         <span class="comment">% performed.</span>
0125         <span class="comment">%</span>
0126         <span class="comment">% return_dot_data: if equals to 'yes' then dot data for all</span>
0127         <span class="comment">% generalized tensor multiplication operations are returned</span>
0128         <span class="comment">% in a string. In this case contract_type is expected to be</span>
0129         <span class="comment">% equal to 'optimal', operation_type is expected to be</span>
0130         <span class="comment">% equal to 'mem_analysis', iternum is expected to be equal</span>
0131         <span class="comment">% to 1 . See pltf_optimal_dot function for example usage.</span>
0132 
0133             <span class="keyword">if</span> nargin == 2
0134                 contract_type = <span class="string">''</span>;
0135             <span class="keyword">end</span>
0136             <span class="keyword">if</span> nargin &lt; 4
0137                 operation_type = <span class="string">'compute'</span>;
0138             <span class="keyword">end</span>
0139             <span class="keyword">if</span> nargin &lt; 5
0140                 return_dot_data = <span class="string">'no'</span>;
0141             <span class="keyword">end</span>
0142             dot_data = <span class="string">''</span>;
0143 
0144 
0145             <span class="comment">% init optimal model cache</span>
0146             <span class="keyword">global</span> ocs_cache;
0147             ocs_cache = [];
0148 
0149             <span class="comment">% initalize obj.cost with memory requirements of the</span>
0150             <span class="comment">% model elements</span>
0151             obj.cost = obj.get_element_size();
0152             display( [ <span class="string">'obj.cost '</span> num2str(obj.cost) ] );
0153 
0154             hat_X = obj.observed_factor;
0155             hat_X.name = <span class="string">'hat_X'</span>;
0156             <span class="comment">% hat_X requires extra memory</span>
0157             obj.cost = obj.cost + hat_X.get_element_size();
0158             display( [ <span class="string">'obj.cost '</span> num2str(obj.cost) ] );
0159 
0160             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0161                 eval( [ <span class="string">'global '</span> obj.get_factor_data_name( obj.observed_factor) <span class="keyword">...</span>
0162                         <span class="string">';'</span> ] );
0163                 <span class="keyword">global</span> hat_X_data;
0164                 hat_X.rand_init(obj.dims, 100);
0165             <span class="keyword">end</span>
0166 
0167             mask = obj.observed_factor;
0168             mask.name = <span class="string">'mask'</span>;
0169             <span class="comment">% mask requires extra memory</span>
0170             obj.cost = obj.cost + mask.get_element_size();
0171             display( [ <span class="string">'obj.cost '</span> num2str(obj.cost) ] );
0172 
0173             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0174                 <span class="keyword">global</span> mask_data;
0175                 mask_data = ones(size(hat_X_data));
0176                 KL=zeros(1,iternum);
0177                 <span class="keyword">for</span> iter = 1:iternum
0178                     display([<span class="string">'iteration'</span> char(9) num2str(iter)]);
0179                     [ kl cost ] = obj.pltf_iteration(contract_type, <span class="keyword">...</span>
0180                                                      hat_X, <span class="keyword">...</span>
0181                                                      mask, <span class="keyword">...</span>
0182                                                      operation_type);
0183                     KL(iter) = kl;
0184                 <span class="keyword">end</span>
0185 
0186                 display([<span class="string">'KL divergence over iterations: '</span>]);
0187                 display(KL);
0188                 plot(KL);
0189                 title(<span class="string">'KL divergence over iterations'</span>);
0190                 xlabel(<span class="string">'iteration number'</span>);
0191                 ylabel(<span class="string">'KL divergence'</span>);
0192 
0193             <span class="keyword">elseif</span> strcmp( operation_type, <span class="string">'mem_analysis'</span> )
0194                 [ kl cost dot_data ] = <span class="keyword">...</span>
0195                     obj.pltf_iteration(contract_type, hat_X, <span class="keyword">...</span>
0196                                        mask, <span class="keyword">...</span>
0197                                        operation_type, <span class="keyword">...</span>
0198                                        return_dot_data );
0199             <span class="keyword">end</span>
0200 
0201 
0202 
0203             obj.cost = obj.cost + cost;
0204             display( [<span class="string">'e9 '</span> num2str(obj.cost) <span class="string">' &lt;- '</span> num2str(cost) ] );
0205 
0206             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'full'</span> )
0207                 <span class="keyword">global</span> F_size;
0208                 obj.cost = obj.cost + F_size;
0209                 display([ <span class="string">'e10 '</span> num2str(obj.cost) <span class="string">' &lt;- '</span> <span class="keyword">...</span>
0210                           num2str(F_size) ]);
0211             <span class="keyword">end</span>
0212 
0213             display([char(10) <span class="keyword">...</span>
0214                      <span class="string">'data elements required: '</span> num2str(obj.cost) <span class="keyword">...</span>
0215                      char(10) <span class="keyword">...</span>
0216                      [<span class="string">'memory size with (8 byte) double precision: '</span> <span class="keyword">...</span>
0217                       num2str(8 * obj.cost / 1000 / 1000) <span class="string">' MB'</span> ] ] );
0218         <span class="keyword">end</span>
0219 
0220 
0221 
0222 
0223         <a name="_sub3" href="#_subfunctions" class="code">function [ kl cost dot_data ] = pltf_iteration(obj, </a><span class="keyword">...</span>
0224                                                    contract_type, <span class="keyword">...</span>
0225                                                    hat_X, mask, <span class="keyword">...</span>
0226                                                    operation_type, <span class="keyword">...</span>
0227                                                    return_dot_data )
0228             <span class="comment">% helper function for the pltf inner loop</span>
0229             <span class="comment">% operation_type: 'compute' if actual computation is</span>
0230             <span class="comment">% requested, 'mem_analysis' if only memory usage</span>
0231             <span class="comment">% computation is requested</span>
0232             <span class="comment">%</span>
0233             <span class="comment">% returns KL divergence value calculated at the end of</span>
0234             <span class="comment">% the operations. dot_data contains</span>
0235             <span class="comment">% graphviz data for the generalized tensor</span>
0236             <span class="comment">% multiplication operations if return_dot_data is equal</span>
0237             <span class="comment">% to 'yes'.</span>
0238 
0239             <span class="keyword">if</span> nargin &lt; 6
0240                 return_dot_data = <span class="string">'no'</span>;
0241             <span class="keyword">end</span>
0242             dot_data = <span class="string">''</span>;
0243 
0244             cost = 0;
0245             <span class="keyword">for</span> alpha=1:length(obj.latent_factor_indices)
0246                 <span class="comment">% access global data</span>
0247                 X_name = obj.get_factor_data_name( obj.observed_factor );
0248                 eval( [ <span class="string">'global '</span> X_name <span class="string">';'</span> ] );
0249 
0250                 hat_X_data_name = obj.get_factor_data_name( hat_X );
0251                 eval( [ <span class="string">'global '</span>  hat_X_data_name <span class="string">';'</span>] );
0252                 
0253                 mask_name =  obj.get_factor_data_name( mask );
0254                 eval( [ <span class="string">'global '</span> mask_name <span class="string">';'</span> ] ); 
0255 
0256 
0257                 <span class="comment">% recalculate hat_X</span>
0258                 newmodel = obj;
0259 
0260 
0261                 <span class="comment">% only not used if full, compute, no (so do it</span>
0262                 <span class="comment">% always) was under if below</span>
0263                 graph = newmodel.schedule_dp();                
0264                 <span class="keyword">if</span> strcmp(return_dot_data, <span class="string">'yes'</span>)
0265                     <span class="keyword">global</span> last_node_id;
0266                     [str last_node_id] = graph.print_dot(last_node_id, <span class="keyword">...</span>
0267                                                          <span class="string">'re-calculate hat_X'</span>);
0268                     dot_data = [ str char(10) dot_data ];
0269 
0270                     <span class="keyword">global</span> oru_models;
0271                     <span class="keyword">if</span> ~length(oru_models)
0272                         oru_models = [ newmodel ];
0273                     <span class="keyword">end</span>
0274                 <span class="keyword">end</span>
0275 
0276                 <span class="comment">% perform contraction</span>
0277                 <span class="comment">% store result in hat_X_data</span>
0278                 [ ~ ] = <span class="keyword">...</span>
0279                     newmodel.contract_all(contract_type, <span class="keyword">...</span>
0280                                           operation_type, <span class="keyword">...</span>
0281                                           hat_X_data_name, graph);
0282                 <span class="keyword">if</span> strcmp(contract_type, <span class="string">'optimal'</span>)
0283                     <span class="comment">% does not work on 'full' contraction</span>
0284                     cost = cost + graph.get_optimal_path_cost();
0285                 <span class="keyword">end</span>
0286                 display( [<span class="string">'e1 X_hat '</span> num2str(cost) <span class="string">' &lt;- '</span> <span class="keyword">...</span>
0287                           num2str(graph.get_optimal_path_cost()) <span class="keyword">...</span>
0288                          ] );
0289 
0290 
0291                 <span class="comment">%result_name = ...</span>
0292                 <span class="comment">%    newmodel.get_first_non_observed_factor() ...</span>
0293                 <span class="comment">%    .get_data_name();</span>
0294                 <span class="comment">%eval(['global ' result_name ';'] );</span>
0295                 <span class="comment">%eval(['hat_X_data = ' result_name ';' ] );</span>
0296 
0297 
0298 
0299                 <span class="comment">% store X / hat_X in hat_X data</span>
0300                 <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0301                     eval( [ hat_X_data_name <span class="string">'  =  '</span> <span class="keyword">...</span>
0302                             X_name <span class="keyword">...</span>
0303                             <span class="string">' ./ '</span> <span class="keyword">...</span>
0304                             hat_X_data_name <span class="string">' ;'</span> ] );
0305                 <span class="keyword">end</span>
0306 
0307 
0308                 <span class="comment">% generate D1</span>
0309                 [ dd c ] = obj.delta(alpha, <span class="string">'D1_data'</span>, <span class="keyword">...</span>
0310                                         contract_type, <span class="keyword">...</span>
0311                                         operation_type, <span class="keyword">...</span>
0312                                         hat_X, <span class="keyword">...</span>
0313                                         return_dot_data );
0314                 <span class="keyword">if</span> strcmp( return_dot_data, <span class="string">'yes'</span>) 
0315                     dot_data = [ dd char(10) dot_data ];
0316                 <span class="keyword">end</span>
0317 
0318                 Z_alpha_name = obj.get_factor_data_name( <span class="keyword">...</span>
0319                     obj.factors(alpha) );
0320                 eval( [ <span class="string">'global '</span> Z_alpha_name <span class="string">';'</span> ] );
0321 
0322                 <span class="keyword">if</span> strcmp(contract_type, <span class="string">'optimal'</span>)
0323                     cost = cost + c + <span class="keyword">...</span>
0324                            global_data_size(Z_alpha_name);
0325                 <span class="keyword">else</span>
0326                     <span class="comment">% for full contraction type</span>
0327                     cost = cost + global_data_size(Z_alpha_name);
0328                 <span class="keyword">end</span>
0329 
0330                 display( [<span class="string">'e2 D1 Z_'</span> num2str(alpha) <span class="string">' '</span> num2str(cost) <span class="string">' c '</span> <span class="keyword">...</span>
0331                           num2str(c) <span class="string">' '</span> num2str(global_data_size(Z_alpha_name)) <span class="keyword">...</span>
0332                          ] );
0333 
0334                 <span class="comment">% generate D2</span>
0335                 [ dd ] = obj.delta(alpha, <span class="string">'D2_data'</span>, <span class="keyword">...</span>
0336                                    contract_type, <span class="keyword">...</span>
0337                                    operation_type, <span class="keyword">...</span>
0338                                    mask, <span class="keyword">...</span>
0339                                    return_dot_data);
0340                 <span class="keyword">if</span> strcmp( return_dot_data, <span class="string">'yes'</span>) 
0341                     dot_data = [ dd char(10) dot_data ];
0342                 <span class="keyword">end</span>
0343 
0344                 <span class="comment">% works for both optimal and full contraction</span>
0345                 cost = cost + global_data_size(Z_alpha_name);
0346                 display( [<span class="string">'e2 D1 Z_'</span> num2str(alpha) <span class="string">' '</span> num2str(cost) <span class="string">' '</span> <span class="keyword">...</span>
0347                           num2str(global_data_size(Z_alpha_name)) <span class="keyword">...</span>
0348                          ] );
0349 
0350 
0351                 <span class="comment">% update Z_alpha</span>
0352                 <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0353                     <span class="keyword">global</span> D1_data D2_data;
0354                     eval( [ Z_alpha_name <span class="string">'='</span> Z_alpha_name <span class="string">' .* '</span> <span class="keyword">...</span>
0355                             <span class="string">'D1_data'</span>                     <span class="string">' ./ '</span> <span class="keyword">...</span>
0356                             <span class="string">'D2_data ;'</span> ] );
0357                 <span class="keyword">end</span>
0358             <span class="keyword">end</span>
0359 
0360             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0361                 <span class="comment">% calculate KL divergence</span>
0362                 eval ( [ <span class="string">'kl = sum(sum(sum( ('</span> hat_X_data_name <span class="string">' .* '</span> X_name <span class="string">') .* '</span> <span class="keyword">...</span>
0363                          <span class="string">' (log( ('</span> hat_X_data_name <span class="string">' .* '</span> X_name <span class="string">') ) - '</span> <span class="keyword">...</span>
0364                          <span class="string">'log('</span> X_name <span class="keyword">...</span>
0365                          <span class="string">') ) - ( '</span> hat_X_data_name <span class="string">' .* '</span> X_name <span class="string">')'</span> <span class="keyword">...</span>
0366                          <span class="string">'+ '</span> X_name <span class="keyword">...</span>
0367                          <span class="string">')));'</span> ]);
0368             <span class="keyword">else</span>
0369                 kl = 0;
0370             <span class="keyword">end</span>
0371 
0372         <span class="keyword">end</span>
0373 
0374 
0375 
0376 
0377         <a name="_sub4" href="#_subfunctions" class="code">function [ dot_data cost ] = delta(obj, alpha, </a><span class="keyword">...</span>
0378                                                 output_name, <span class="keyword">...</span>
0379                                                 contract_type, <span class="keyword">...</span>
0380                                                 operation_type, <span class="keyword">...</span>
0381                                                 A, return_dot_data)
0382         <span class="comment">% PLTF delta function implementation</span>
0383         <span class="comment">% alpha: index of latent factor in PLTFModel.factors array</span>
0384         <span class="comment">% which will be updated</span>
0385         <span class="comment">% name: unique name used as the name of calculated delta</span>
0386         <span class="comment">% factor data</span>
0387         <span class="comment">% contract_type: see description in pltf function</span>
0388         <span class="comment">% A: operand element of delta function assumed all ones if</span>
0389         <span class="comment">% not given</span>
0390         <span class="comment">%</span>
0391         <span class="comment">% dot_data contains</span>
0392         <span class="comment">% graphviz data for the generalized tensor</span>
0393         <span class="comment">% multiplication operations if return_dot_data is equal</span>
0394         <span class="comment">% to 'yes'.</span>
0395 
0396             
0397             <span class="keyword">if</span> nargin &lt; 7
0398                 return_dot_data = <span class="string">'no'</span>;
0399             <span class="keyword">end</span>
0400 
0401             dot_data = <span class="string">''</span>;
0402 
0403             <span class="comment">% create new model for delta operation</span>
0404             d_model = obj;
0405 
0406             <span class="comment">% remove observed factor</span>
0407             d_model.factors(d_model.observed_factor_index) = [];
0408 
0409             <span class="comment">% add Z_alpha as new observed factor</span>
0410             d_model.factors(alpha).isLatent = 0;
0411             d_model.factors(alpha).isObserved= 1;
0412 
0413             <span class="comment">% if given, add A as a new latent factor</span>
0414             <span class="keyword">if</span> nargin == 7
0415                 A.isLatent = 1;
0416                 A.isObserved = 0;
0417                 d_model.factors = [d_model.factors A];
0418             <span class="keyword">end</span>
0419 
0420 
0421             <span class="comment">% only not used if full, compute, no (so do it</span>
0422             <span class="comment">% always) was under if below</span>
0423             graph = d_model.schedule_dp();
0424             <span class="keyword">if</span> strcmp(return_dot_data, <span class="string">'yes'</span>)
0425                 <span class="keyword">global</span> last_node_id;
0426                 title = [<span class="string">'alpha '</span> num2str(alpha) <span class="string">' '</span> <span class="keyword">...</span>
0427                          output_name ];
0428                 [ dot_data last_node_id ] = <span class="keyword">...</span>
0429                     graph.print_dot(last_node_id, <span class="keyword">...</span>
0430                                     title );
0431 
0432                 <span class="keyword">if</span> strcmp(output_name, <span class="string">'D1_data'</span>)
0433                     <span class="keyword">global</span> oru_models;
0434                     oru_model = d_model;
0435                     oru_model.name = title;
0436                     oru_models = [ oru_models oru_model ];
0437                 <span class="keyword">end</span>
0438             <span class="keyword">end</span>
0439 
0440             <span class="comment">% perform contraction</span>
0441             [ ~ ] = d_model.contract_all(contract_type, <span class="keyword">...</span>
0442                                               operation_type, <span class="keyword">...</span>
0443                                               output_name, graph);
0444 
0445             <span class="comment">%'e4'</span>
0446             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'optimal'</span> )
0447                 cost = graph.get_optimal_path_cost();
0448             <span class="keyword">else</span>
0449                 <span class="comment">% does not work on full contraction type</span>
0450                 cost = 0;
0451             <span class="keyword">end</span>
0452         <span class="keyword">end</span>
0453 
0454 
0455 
0456 
0457         <a name="_sub5" href="#_subfunctions" class="code">function [graph] = schedule_dp(obj)</a>
0458         <span class="comment">% returns a tree of PLTFModel generated as a result of the</span>
0459         <span class="comment">% search for least memory consuming contraction sequence</span>
0460         <span class="comment">% with a dynamic programming approach</span>
0461 
0462             output_dims = obj.get_contraction_dims();
0463             contraction_dims = obj.get_contraction_dims();
0464             
0465             graph = <a href="GTMGraph.html" class="code" title="">GTMGraph</a>;
0466             process_nodes = [obj];
0467             processing_node = 1;
0468 
0469             <span class="comment">% init graph.node_list</span>
0470             graph.node_list = obj;
0471             graph=graph.clear_edges();
0472 
0473             <span class="keyword">while</span> length(process_nodes) &gt;= processing_node
0474                 cur_node = process_nodes(processing_node);
0475                 <span class="comment">%cur_node = cur_node.update_cost_from_temp();</span>
0476 
0477                 contraction_dims = cur_node.get_current_contraction_dims();
0478                 <span class="keyword">for</span> udi = 1:length(contraction_dims)
0479 
0480                     new_node = cur_node.contract( contraction_dims(udi), <span class="keyword">...</span>
0481                                                   <span class="string">'mem_analysis'</span>, <span class="keyword">...</span>
0482                                                   <span class="string">''</span> );
0483 
0484                     <span class="comment">% last operation does not have memory cost data</span>
0485                     <span class="comment">% is handled outside of pltf_iteration</span>
0486                     <span class="keyword">if</span> ~length(new_node.get_current_contraction_dims())
0487                         new_node.cost = 0;
0488                     <span class="keyword">end</span>
0489 
0490                     <span class="comment">% memoization</span>
0491                     nnidx = graph.exists(new_node);
0492                     <span class="keyword">if</span> nnidx
0493                         <span class="comment">%['old node ' new_node.name]</span>
0494                         graph = graph.update_node(cur_node, new_node, nnidx);
0495                     <span class="keyword">else</span>
0496                         <span class="comment">%['new node ' new_node.name]</span>
0497                         graph = graph.append_node(cur_node, new_node);
0498                         process_nodes = [ process_nodes new_node ];
0499                     <span class="keyword">end</span>
0500                 <span class="keyword">end</span>
0501 
0502                 processing_node = processing_node + 1;
0503 
0504             <span class="keyword">end</span>
0505 
0506         <span class="keyword">end</span>
0507 
0508 
0509 
0510 
0511 
0512         <a name="_sub6" href="#_subfunctions" class="code">function [newmodel ] = contract_all(obj, contract_type, </a><span class="keyword">...</span>
0513                                                      operation_type, <span class="keyword">...</span>
0514                                                      output_name, graph )
0515         <span class="comment">% Performs all necessary contraction operations for the</span>
0516         <span class="comment">% model. If contract_type argument is equal to 'optimal'</span>
0517         <span class="comment">% then schedule_dp() is used to find the optimal (least</span>
0518         <span class="comment">% memory using) sequence and the optimal sequence is used</span>
0519         <span class="comment">% to contract all necessary dimensions. Otherwise</span>
0520         <span class="comment">% get_contraction_dims() is used to order contraction</span>
0521         <span class="comment">% operation which does not order dimensions. If</span>
0522         <span class="comment">% contract_type equals to 'full', no intermediate</span>
0523         <span class="comment">% contractions are performed, full tensor is calculated and</span>
0524         <span class="comment">% then contracted into the output tensor</span>
0525         <span class="comment">% output_name: name of the global data structure to store</span>
0526         <span class="comment">% the final result into, not used if operation type is not</span>
0527         <span class="comment">% 'compute'.</span>
0528         <span class="comment">%</span>
0529         <span class="comment">% operation_type argument may be 'compute' or</span>
0530         <span class="comment">% 'mem_analysis'. Normal operations are performed in</span>
0531         <span class="comment">% 'compute' (default), memory usage is reported in</span>
0532         <span class="comment">% 'mem_analysis' case.</span>
0533         <span class="comment">%</span>
0534         <span class="comment">% returns the model generated after contracting all</span>
0535         <span class="comment">% necessary dimension and the total extra memory required</span>
0536         <span class="comment">% by all temporary elements</span>
0537 
0538             <span class="keyword">if</span> nargin &lt; 4
0539                 output_name = <span class="string">''</span>;
0540             <span class="keyword">end</span>
0541 
0542             <span class="keyword">if</span> nargin &lt; 3
0543                 operation_type = <span class="string">'compute'</span>;
0544             <span class="keyword">end</span>
0545 
0546             <span class="keyword">if</span> nargin &lt; 2
0547                 contract_type = <span class="string">'standard'</span>;
0548             <span class="keyword">end</span>
0549 
0550             <span class="keyword">if</span> strcmp(operation_type, <span class="string">'compute'</span>) &amp;&amp; <span class="keyword">...</span>
0551                     isempty(output_name)
0552                 throw(MException(<span class="string">'PLTFModel:ContractAllNoOutputName'</span>, <span class="keyword">...</span>
0553                                  [<span class="string">'output_name must be specified if '</span> <span class="keyword">...</span>
0554                                   <span class="string">'operation type is ''compute'''</span> ]));
0555             <span class="keyword">end</span>
0556 
0557 
0558 
0559             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'optimal'</span> )
0560                 [contract_dims] = <span class="keyword">...</span>
0561                     obj.get_optimal_contraction_sequence_dims(graph);
0562 
0563                 <span class="comment">%for i=1:length(contract_dims)</span>
0564                 <span class="comment">%    display(['optimal contracting ' ...</span>
0565                 <span class="comment">%             char(contract_dims{i})]);</span>
0566                 <span class="comment">%end</span>
0567             <span class="keyword">elseif</span>  ~strcmp( contract_type, <span class="string">'full'</span> )
0568                 contract_dims = obj.get_contraction_dims();
0569 
0570                 <span class="comment">%for i=1:length(contract_dims)</span>
0571                 <span class="comment">%    display(['contracting ' contract_dims(i).name]);</span>
0572                 <span class="comment">%end</span>
0573             <span class="keyword">end</span>
0574 
0575 
0576 
0577 
0578             newmodel = obj;
0579 
0580             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'full'</span>)
0581                 [ newmodel ] = <span class="keyword">...</span>
0582                     obj.contract_full(operation_type, output_name);
0583                 <span class="comment">%['e5' contract_type]</span>
0584             <span class="keyword">else</span>
0585                 <span class="keyword">for</span> i = 1:length(contract_dims)
0586                     <span class="keyword">if</span> i == length(contract_dims)
0587                         on = output_name;
0588                     <span class="keyword">else</span>
0589                         on = <span class="string">''</span>;
0590                     <span class="keyword">end</span>
0591 
0592                     [ newmodel ]= <span class="keyword">...</span>
0593                         newmodel.contract(contract_dims(i), <span class="keyword">...</span>
0594                                           operation_type, <span class="keyword">...</span>
0595                                           on );
0596 
0597                 <span class="keyword">end</span>
0598             <span class="keyword">end</span>
0599         <span class="keyword">end</span>
0600 
0601 
0602 
0603 
0604         <a name="_sub7" href="#_subfunctions" class="code">function [newmodel] = contract_full(obj, operation_type, </a><span class="keyword">...</span>
0605                                                       output_name)
0606         <span class="comment">% generates a new full (temporary) tensor, multiplies all</span>
0607         <span class="comment">% latent tensors in to the full tensor and then</span>
0608         <span class="comment">% contracts full tensor over necessary indices and returns</span>
0609         <span class="comment">% newmodel with full_tensor and contracted result in global</span>
0610         <span class="comment">% data named 'output_name'</span>
0611 
0612             <span class="comment">% generate full tensor</span>
0613             F = <a href="TFFactor.html" class="code" title="">TFFactor</a>;
0614             F.name = <span class="string">'full_tensor'</span>;
0615             F.isTemp = 1;
0616             F.dims = obj.dims;    <span class="comment">% full indices</span>
0617             <span class="keyword">global</span> F_size;
0618             F_size = F.get_element_size();
0619 
0620             <span class="keyword">global</span> full_tensor_data;
0621 
0622             eval([ <span class="string">'global '</span> output_name ]);
0623 
0624             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0625                 <span class="comment">% generate global full_tensor_data</span>
0626 
0627                 sz = <span class="string">''</span>;
0628                 <span class="keyword">for</span> adi = 1:length(obj.dims)
0629                     <span class="keyword">if</span> adi ~= 1
0630                         sz = [sz <span class="string">', '</span>];
0631                     <span class="keyword">end</span>
0632                     sz = [sz num2str(obj.dims(adi).cardinality) ];
0633                 <span class="keyword">end</span>
0634                 eval( [ <span class="string">' full_tensor_data = ones('</span> sz <span class="string">');'</span>] );
0635             <span class="keyword">else</span>
0636                 <span class="comment">% in case of mem_analysis  make length of global data</span>
0637                 <span class="comment">% greater than 0 for memory size computation</span>
0638                 full_tensor_data = 1;
0639             <span class="keyword">end</span>
0640 
0641             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0642                 <span class="comment">% access global data of all latent factors</span>
0643                 lfi = obj.latent_factor_indices;
0644                 <span class="keyword">for</span> lfii = 1:length(lfi)
0645                     eval([<span class="string">'global '</span> <span class="keyword">...</span>
0646                           obj.get_factor_data_name( obj.factors(lfi(lfii)) ) <span class="keyword">...</span>
0647                          ]);
0648                 <span class="keyword">end</span>
0649 
0650                 <span class="comment">% multiply all latent tensors, store result in data_F</span>
0651                 <span class="keyword">for</span> lfii = 1:length(lfi)
0652                     <span class="comment">% following tensors should be multiplied with data_F</span>
0653                     eval([ <span class="string">'full_tensor_data = bsxfun(@times, full_tensor_data, '</span> <span class="keyword">...</span>
0654                            obj.get_factor_data_name( <span class="keyword">...</span>
0655                                obj.factors(lfi(lfii)) ) <span class="string">');'</span> ]);
0656                 <span class="keyword">end</span>
0657 
0658                 <span class="comment">% contract necessary dimensions from full_tensor_data</span>
0659                 contract_dims = obj.get_contraction_dims();
0660                 <span class="keyword">for</span> cdi = 1:length(contract_dims)
0661                     <span class="keyword">if</span> cdi == length(contract_dims)
0662                         eval( [ output_name [ <span class="string">' = sum( full_tensor_data,'</span> <span class="keyword">...</span>
0663                                             <span class="string">' obj.get_dimension_index('</span> <span class="keyword">...</span>
0664                                             <span class="string">' contract_dims(cdi)) '</span> <span class="keyword">...</span>
0665                                             <span class="string">');'</span> ] ] );
0666                     <span class="keyword">else</span>
0667                         full_tensor_data = sum( full_tensor_data,        <span class="keyword">...</span>
0668                                                 obj.get_dimension_index( <span class="keyword">...</span>
0669                                                     contract_dims(cdi)) <span class="keyword">...</span>
0670                                                 );
0671                     <span class="keyword">end</span>                        
0672                 <span class="keyword">end</span>
0673             <span class="keyword">end</span>
0674 
0675             newmodel = obj;
0676             newmodel.factors = [ obj.observed_factor F ];
0677         <span class="keyword">end</span>
0678 
0679 
0680 
0681 
0682         <a name="_sub8" href="#_subfunctions" class="code">function [newmodel] = contract(obj, dim, operation_type, </a><span class="keyword">...</span>
0683                                                  output_name)
0684         <span class="comment">% returns a new PLTFModel generated by contracting obj with</span>
0685         <span class="comment">% dim which may add new temporary factors and mem_delta</span>
0686         <span class="comment">% integer value.</span>
0687         <span class="comment">% dim: TFDimension or char array or cell with the name of</span>
0688         <span class="comment">% the dimension</span>
0689         <span class="comment">% operation_type: if equals to 'compute' contraction is</span>
0690         <span class="comment">% calculated. if equals to 'mem_analysis' data elements are</span>
0691         <span class="comment">% not created.</span>
0692         <span class="comment">% output_name: if has length &gt; 0 do not generate temporary</span>
0693         <span class="comment">% factor but use global data storage named 'output</span>
0694         <span class="comment">% name'.</span>
0695         <span class="comment">%[ 'contract START dim length ' num2str(length(dim))]</span>
0696 
0697             <span class="keyword">if</span> length(dim) == 0
0698                 throw(MException(<span class="string">'PLTFModel:NoContractionDimensionSpecified'</span>, <span class="keyword">...</span>
0699                                  [<span class="string">'must specify contraction '</span> <span class="keyword">...</span>
0700                                   <span class="string">'dimension'</span>]));
0701             <span class="keyword">end</span>
0702 
0703 
0704             <span class="keyword">if</span> isa(dim, <span class="string">'TFDimension'</span>)
0705                 dim = dim.name;
0706             <span class="keyword">elseif</span> isa(dim, <span class="string">'cell'</span>)
0707                 dim = char(dim{1});
0708             <span class="keyword">elseif</span> ~isa(dim, <span class="string">'char'</span>)
0709                 display([<span class="string">'ERROR: unsupported dim type '</span> class(dim) <span class="keyword">...</span>
0710                          <span class="string">'was expecting TFDimension, cell or char '</span> <span class="keyword">...</span>
0711                          <span class="string">'array'</span>]);
0712                 <span class="keyword">return</span>
0713             <span class="keyword">end</span>
0714 
0715             newmodel = obj;
0716             newmodel.name = [obj.name <span class="string">'_'</span> dim];
0717 
0718             <span class="comment">% remove dim from the new model's factors'</span>
0719             contracted_factor_inds = [];
0720             <span class="keyword">for</span> f = 1:length(newmodel.factors)
0721                 <span class="keyword">if</span> ~newmodel.factors(f).isObserved
0722                     ind = <span class="keyword">...</span>
0723                         newmodel.factors(f).got_dimension(char(dim));
0724                     
0725                     <span class="keyword">if</span> ind ~= 0
0726                         <span class="comment">% remove this dimension from this factor</span>
0727                         newmodel.factors(f).dims(ind) = [];
0728 
0729                         contracted_factor_inds = <span class="keyword">...</span>
0730                             [ contracted_factor_inds f ];
0731                     <span class="keyword">end</span>
0732                 <span class="keyword">end</span>
0733             <span class="keyword">end</span>
0734 
0735             <span class="comment">% add a temporary factor including dimensions of</span>
0736             <span class="comment">% contracted factors other than contracted dimension</span>
0737             tmp=<a href="TFFactor.html" class="code" title="">TFFactor</a>;
0738             tmp.isTemp = 1;
0739             tmp.name = <span class="string">'tmp'</span>;
0740             names={};
0741             
0742             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0743                 <span class="comment">% for each dimension of the contracted factor</span>
0744                 <span class="keyword">for</span> cfi_dim = 1:length(newmodel.factors(contracted_factor_inds(cfii)).dims)
0745                     found=0;
0746                     <span class="keyword">for</span> ti = 1:length(tmp.dims)
0747                         <span class="keyword">if</span> tmp.dims(ti) == <span class="keyword">...</span>
0748                                 newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim)
0749                             found=1;
0750                             <span class="keyword">break</span>;
0751                         <span class="keyword">end</span>
0752                     <span class="keyword">end</span>
0753                     <span class="keyword">if</span> found == 0
0754                         tmp.dims = [tmp.dims <span class="keyword">...</span>
0755                                     newmodel.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0756                                     .dims(cfi_dim)];
0757                         names=[names <span class="keyword">...</span>
0758                               newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name];
0759                         <span class="comment">%display(['added from factor index' ...</span>
0760                         <span class="comment">%         contracted_factor_inds(cfii)])</span>
0761                         <span class="comment">%display(['added from factor' newmodel.factors(contracted_factor_inds(cfii)).name])</span>
0762                         <span class="comment">%display(['addd dim' char(newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name)])</span>
0763                     <span class="keyword">end</span>
0764                 <span class="keyword">end</span>
0765             <span class="keyword">end</span>
0766             names=unique(names);
0767             <span class="keyword">for</span> d = 1:length(names)
0768                 tmp.name = [tmp.name <span class="string">'_'</span> char(names(d))];
0769                 <span class="comment">%tmp.name</span>
0770             <span class="keyword">end</span>
0771             tmp.name = [tmp.name <span class="string">'_minus_'</span> dim];
0772 
0773 
0774 
0775 
0776             <span class="comment">% calculate output data</span>
0777             <span class="keyword">if</span> isempty(output_name)
0778                 <span class="comment">% if output if not given store in global variable</span>
0779                 <span class="comment">% with tmp.coded_name</span>
0780                 on = obj.get_factor_data_name(tmp);
0781                 <span class="comment">%eval( [ 'global ' on ';' ])</span>
0782            <span class="keyword">else</span>
0783                 on = output_name;
0784 
0785                 <span class="comment">% TODO: make sure output has correct dimensions</span>
0786                 <span class="comment">% eval( [ 'global ' on  ';'] );</span>
0787                 <span class="comment">% tmpsz = size(tmp.get_data_name());</span>
0788             <span class="keyword">end</span>
0789 
0790 
0791             <span class="comment">%['SELECTED on ' on  ' tmp.name ' tmp.name ' operation_type ' ...</span>
0792             <span class="comment">% operation_type]</span>
0793             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0794                 eval( [ <span class="string">'global '</span> on  <span class="string">';'</span>] );
0795 
0796                 <span class="comment">%[ 'on0: ' on '' ]</span>
0797                 <span class="comment">%eval([ 'on_len0 = length( ' on ' )' ]);</span>
0798 
0799 
0800                 <span class="keyword">if</span> length(contracted_factor_inds) == 1
0801                     <span class="comment">%'sdfa111'</span>
0802                     <span class="comment">% no multiplication</span>
0803                     eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0804                             obj.get_factor_data_name( obj.factors(contracted_factor_inds(1)) ) <span class="keyword">...</span>
0805                             <span class="string">';'</span>] );
0806                     <span class="comment">%['aa :' obj.get_factor_data_name( ...</span>
0807                     <span class="comment">%    obj.factors(contracted_factor_inds(1)) ) ]</span>
0808                     <span class="comment">%['aalen :']</span>
0809                     eval( [ <span class="string">'length( '</span> obj.get_factor_data_name( <span class="keyword">...</span>
0810                         obj.factors(contracted_factor_inds(1)) ) <span class="string">');'</span> ])
0811 
0812 
0813                     <span class="comment">%[ obj.get_factor_data_name( ...</span>
0814                     <span class="comment">%    obj.factors(contracted_factor_inds(1)) ) ...</span>
0815                     <span class="comment">%  ' -&gt; ' ...</span>
0816                     <span class="comment">%  on ]</span>
0817                     eval( [ on <span class="string">' = '</span> <span class="keyword">...</span>
0818                             obj.get_factor_data_name( obj.factors(contracted_factor_inds(1)) ) <span class="keyword">...</span>
0819                             <span class="string">';'</span>] );
0820                 <span class="keyword">else</span>
0821                     <span class="comment">%'sdfa222'</span>
0822                     <span class="comment">% multiply first two into tmp data</span>
0823                     eval( [ <span class="string">'global'</span> <span class="keyword">...</span>
0824                             <span class="string">' '</span> obj.get_factor_data_name( obj.factors(contracted_factor_inds(1)) ) <span class="keyword">...</span>
0825                             <span class="string">' '</span> obj.get_factor_data_name( obj.factors(contracted_factor_inds(2)) ) <span class="keyword">...</span>
0826                             <span class="string">';'</span>] );
0827 
0828 
0829                     <span class="comment">%[ obj.get_factor_data_name( ...</span>
0830                     <span class="comment">%    obj.factors(contracted_factor_inds(1)) ) ...</span>
0831                     <span class="comment">%  ' * ' ...</span>
0832                     <span class="comment">%  obj.get_factor_data_name( ...</span>
0833                     <span class="comment">%      obj.factors(contracted_factor_inds(2)) ) ...</span>
0834                     <span class="comment">%  ' -&gt; ' ...</span>
0835                     <span class="comment">%  on ]</span>
0836                     eval( [ on <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0837                             obj.get_factor_data_name( obj.factors(contracted_factor_inds(1)) ) <span class="string">', '</span><span class="keyword">...</span>
0838                             obj.get_factor_data_name( obj.factors(contracted_factor_inds(2)) ) <span class="string">');'</span> <span class="keyword">...</span>
0839                           ] );
0840 
0841                     <span class="comment">% multiply tmp data with other factors</span>
0842                     <span class="keyword">for</span> cfii = 3:length(contracted_factor_inds)
0843                         eval( [ <span class="string">'global '</span><span class="keyword">...</span>
0844                                 obj.get_factor_data_name( obj.factors(contracted_factor_inds(cfii)) ) <span class="keyword">...</span>
0845                                 <span class="string">';'</span>] );
0846                         eval( [ on <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0847                                 on <span class="string">','</span><span class="keyword">...</span>
0848                                 obj.get_factor_data_name( obj.factors(contracted_factor_inds(cfii)) ) <span class="keyword">...</span>
0849                                 <span class="string">');'</span> ] );
0850                     <span class="keyword">end</span>
0851                 <span class="keyword">end</span>
0852 
0853 
0854                 <span class="comment">% sum contraction dimensions on tmp data</span>
0855                 
0856                 con_dim_index = obj.get_dimension_index(dim);
0857 
0858                 eval( [ on <span class="string">' = sum( '</span> <span class="keyword">...</span>
0859                         on <span class="string">', '</span> <span class="keyword">...</span>
0860                         num2str(con_dim_index) <span class="string">');'</span>] );
0861 
0862             <span class="keyword">else</span>
0863                 <span class="comment">% in case of mem_analysis  make length of global data</span>
0864                 <span class="comment">% greater than 0 for memory size computation</span>
0865                 
0866                 <span class="comment">% schedule_dp must not perform memory size calculation</span>
0867                 <span class="comment">%stack = dbstack();</span>
0868                 <span class="comment">%if ~strcmp(stack(2).name, ...</span>
0869                 <span class="comment">%           'PLTFModel.schedule_dp')</span>
0870                 <span class="comment">%    eval([ on ' = 1 ;' ]);</span>
0871                 <span class="comment">%end</span>
0872             <span class="keyword">end</span>
0873 
0874 
0875             <span class="keyword">if</span> isempty(output_name)
0876                 newmodel.factors = [newmodel.factors tmp];
0877             <span class="keyword">end</span>
0878 
0879             <span class="comment">% remove contracted factors</span>
0880             <span class="comment">% other dimensions live within the tmp factor</span>
0881             removed_num=0; <span class="comment">% removal breaks loop index</span>
0882             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0883                 newmodel.factors(contracted_factor_inds(cfii) <span class="keyword">...</span>
0884                                  - removed_num) = [];
0885                 removed_num = removed_num + 1;
0886             <span class="keyword">end</span>
0887 
0888 
0889             <span class="keyword">if</span> isempty(output_name)
0890                 newmodel = newmodel.update_cost_from_temp();
0891             <span class="keyword">end</span>
0892         <span class="keyword">end</span>
0893 
0894 
0895 
0896 
0897         <a name="_sub9" href="#_subfunctions" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj, </a><span class="keyword">...</span>
0898                                                               graph)
0899         <span class="comment">% Runs schedule_dp function to generate graph with least</span>
0900         <span class="comment">% memory using contraction sequence information in it. Then</span>
0901         <span class="comment">% searches GTMGraph.optimal_edges for the optimal path and</span>
0902         <span class="comment">% returns a cell list of contraction dimension names.</span>
0903 
0904             <span class="keyword">global</span> ocs_cache;
0905 
0906             found = false;
0907             <span class="keyword">for</span> o = 1:length(ocs_cache)
0908                 <span class="keyword">if</span> ocs_cache(o).model == obj
0909                     found=true;
0910                     <span class="keyword">break</span>
0911                 <span class="keyword">end</span>
0912             <span class="keyword">end</span>
0913 
0914             <span class="keyword">if</span> found
0915                 <span class="comment">%display('cache hit')</span>
0916 
0917                 <span class="comment">%display([ 'ocs dims' ])</span>
0918                 ocs_dims = ocs_cache(o).ocs_dims;
0919                 <span class="comment">%for a =1:length(ocs_dims)</span>
0920                 <span class="comment">%    ocs_dims{a}</span>
0921                 <span class="comment">%end</span>
0922                 <span class="keyword">return</span>
0923             <span class="comment">%else</span>
0924             <span class="comment">%    display('cache miss')</span>
0925             <span class="keyword">end</span>
0926 
0927 
0928             <span class="comment">%graph = obj.schedule_dp();</span>
0929             [ocs_dims] = graph.optimal_sequence_from_graph();
0930             <span class="comment">%cost</span>
0931             <span class="comment">%obj.cost = obj.cost + cost;</span>
0932 
0933 
0934             <span class="comment">%display([ 'cache store' ])</span>
0935             <span class="comment">%for a =1:length(ocs_dims)</span>
0936             <span class="comment">%    ocs_dims{a}</span>
0937             <span class="comment">%end</span>
0938 
0939             ocs_cache = [ ocs_cache <a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>(obj, ocs_dims) ];
0940         <span class="keyword">end</span>
0941 
0942 
0943 
0944 
0945         <a name="_sub10" href="#_subfunctions" class="code">function [obj] = update_cost_from_temp(obj)</a>
0946             obj.cost = 0;
0947             lfi = obj.latent_factor_indices();
0948             <span class="keyword">for</span> fi = 1:length(lfi)
0949                 <span class="keyword">if</span> obj.factors(lfi(fi)).isTemp
0950                     obj.factors(lfi(fi)).name;
0951                     obj.cost = obj.cost + <span class="keyword">...</span>
0952                         obj.factors(lfi(fi)).get_element_size();
0953                 <span class="keyword">end</span>
0954             <span class="keyword">end</span>
0955             <span class="comment">%['updatecost ' obj.name ' ' num2str(obj.cost)]</span>
0956         <span class="keyword">end</span>
0957 
0958 
0959 
0960 
0961         <a name="_sub11" href="#_subfunctions" class="code">function [obj] = update_cost_from_latent(obj)</a>
0962             obj.cost = 0;
0963             lfi=obj.latent_factor_indices();
0964             <span class="keyword">for</span> fi = 1:length(lfi)
0965                 obj.cost = obj.cost + <span class="keyword">...</span>
0966                     obj.factors(lfi(fi)).get_element_size();
0967             <span class="keyword">end</span>
0968         <span class="keyword">end</span>
0969 
0970 
0971 
0972 
0973         <a name="_sub12" href="#_subfunctions" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a>
0974         <span class="comment">% returns a string to be used by fgplot</span>
0975 
0976         <span class="comment">% add dimension nodes</span>
0977             dn = [ <span class="string">'[ '''</span> ];
0978             <span class="keyword">for</span> i =1:length(obj.dims)
0979                 <span class="keyword">if</span> i ~= 1
0980                     dn = [ dn <span class="string">''','''</span> ];
0981                 <span class="keyword">end</span>
0982                 dn = [ dn obj.dims(i).name ];
0983             <span class="keyword">end</span>
0984             dn = [ dn <span class="string">''' ] '</span> ];
0985 
0986             <span class="comment">% add factor nodes</span>
0987             fn = [ <span class="string">'[ '''</span> ];
0988             <span class="keyword">for</span> i =1:length(obj.factors)
0989                 <span class="keyword">if</span> i ~= 1
0990                     fn = [ fn <span class="string">''','''</span> ];
0991                 <span class="keyword">end</span>
0992                 fn = [ fn obj.factors(i).name ];
0993             <span class="keyword">end</span>
0994             fn = [ fn <span class="string">''' ] '</span> ];
0995 
0996             <span class="comment">% add edges</span>
0997             all_edges=[<span class="string">'[ '</span> ];
0998             <span class="keyword">for</span> d = 1:length(obj.dims)
0999                 <span class="keyword">if</span> d ~= 1
1000                     all_edges = [ all_edges <span class="string">' , '</span> ];
1001                 <span class="keyword">end</span>
1002 
1003                 edges=[<span class="string">'[ '</span> ];
1004 
1005                 <span class="comment">% include this dimension if a factor uses it</span>
1006                 <span class="keyword">for</span> f = 1:length(obj.factors)
1007                     <span class="keyword">for</span> fd = 1:length(obj.factors(f).dims)
1008                         <span class="keyword">if</span> obj.factors(f).dims(fd) == obj.dims(d)
1009                             <span class="keyword">if</span> length(edges) ~= 2
1010                                 edges = [ edges <span class="string">''','''</span> ];
1011                             <span class="keyword">else</span>
1012                                 edges = [ edges <span class="string">''''</span> ];
1013                             <span class="keyword">end</span>
1014                             edges = [ edges obj.factors(f).name ];
1015                         <span class="keyword">end</span>
1016                     <span class="keyword">end</span>
1017                 <span class="keyword">end</span>
1018 
1019                 all_edges = [ all_edges edges <span class="string">''' ]'</span> ];
1020             <span class="keyword">end</span>
1021             all_edges = [ all_edges <span class="string">' ]'</span> ];
1022         <span class="keyword">end</span>
1023 
1024 
1025 
1026 
1027         <a name="_sub13" href="#_subfunctions" class="code">function [size] = get_element_size(obj)</a>
1028         <span class="comment">% returns number of elements for this model</span>
1029             size=0;
1030             <span class="keyword">for</span> f = 1:length(obj.factors)
1031                 <span class="comment">% if obj.factors(f).isObserved == 0</span>
1032                 size = size + <span class="keyword">...</span>
1033                        obj.factors(f).get_element_size();
1034                 <span class="comment">%end</span>
1035             <span class="keyword">end</span>
1036         <span class="keyword">end</span>
1037 
1038 
1039 
1040 
1041         <a name="_sub14" href="#_subfunctions" class="code">function [card] = get_index_card(obj, index_char)</a>
1042         <span class="comment">% returns cardinality of a given name of a dimension</span>
1043             <span class="keyword">for</span> d = 1:length(obj.dims)
1044                 <span class="keyword">if</span> obj.dims(d).name == index_char
1045                     card = obj.dims(d).cardinality;
1046                     <span class="keyword">break</span>
1047                 <span class="keyword">end</span>
1048             <span class="keyword">end</span>
1049         <span class="keyword">end</span>
1050 
1051 
1052 
1053 
1054         <a name="_sub15" href="#_subfunctions" class="code">function [factor] = get_first_non_observed_factor(obj)</a>
1055         <span class="comment">% returns first non observed factor index, used to return</span>
1056         <span class="comment">% index of the output factor when all latent factors are</span>
1057         <span class="comment">% contracted out. in this case only output (observed) and a</span>
1058         <span class="comment">% single temporary non-observed factors should be present</span>
1059         <span class="comment">% in the model (ie fully contracted model).</span>
1060             <span class="keyword">for</span> f = 1:length(obj.factors)
1061                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
1062                     factor = obj.factors(f);
1063                     <span class="keyword">return</span>
1064                 <span class="keyword">end</span>
1065             <span class="keyword">end</span>
1066         <span class="keyword">end</span>
1067 
1068 
1069 
1070 
1071         <a name="_sub16" href="#_subfunctions" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a>
1072         <span class="comment">% returns first non observed factor index, used to return</span>
1073         <span class="comment">% index of the output factor</span>
1074             <span class="keyword">for</span> f = 1:length(obj.factors)
1075                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
1076                     ind = f;
1077                     <span class="keyword">return</span>
1078                 <span class="keyword">end</span>
1079             <span class="keyword">end</span>
1080         <span class="keyword">end</span>
1081 
1082 
1083 
1084 
1085         <a name="_sub17" href="#_subfunctions" class="code">function [ind] = find_cell_char(obj, chars)</a>
1086         <span class="comment">% returns index of a given char array in object's dimension array</span>
1087             <span class="keyword">for</span> ind=1:length(obj.dims)
1088                 <span class="keyword">if</span> obj.dims(ind).name == chars
1089                     <span class="keyword">return</span>
1090                 <span class="keyword">end</span>
1091             <span class="keyword">end</span>
1092             ind=0;
1093         <span class="keyword">end</span>
1094 
1095 
1096 
1097 
1098        <a name="_sub18" href="#_subfunctions" class="code">function [r] = get_dimension_index(obj, dim)</a>
1099         <span class="comment">% returns index of dimension dim in obj.dims if obj</span>
1100         <span class="comment">% contains TFDimension (or char) dim returns 0 otherwise</span>
1101 
1102             r=0;
1103             <span class="keyword">for</span> d = 1:length(obj.dims)
1104                 <span class="keyword">if</span> obj.dims(d) == dim
1105                     r=d;
1106                     <span class="keyword">break</span>;
1107                 <span class="keyword">end</span>
1108             <span class="keyword">end</span>           
1109        <span class="keyword">end</span>
1110 
1111 
1112 
1113 
1114        <a name="_sub19" href="#_subfunctions" class="code">function [ordered_index_chars] = order_dims(obj, </a><span class="keyword">...</span>
1115                                                     dims_array)
1116             <span class="comment">% order given cell of dimension names according to</span>
1117             <span class="comment">% factor.dims order</span>
1118 
1119             tmp=cell(length(dims_array), 3);
1120 
1121             tmp(:,1) = dims_array;
1122             <span class="keyword">for</span> i = 1:length(dims_array)
1123                 tmp{i,2} = obj.get_index_card(char(dims_array(i)));
1124                 tmp{i,3} = obj.find_cell_char(char(dims_array(i))); <span class="comment">% order of the index</span>
1125                                                                     <span class="comment">% in the model</span>
1126             <span class="keyword">end</span>
1127 
1128             tmp=sortrows(tmp,3); <span class="comment">% sort by the order of the model indices</span>
1129             ordered_index_chars=tmp(:,1)';
1130         <span class="keyword">end</span>
1131 
1132 
1133 
1134 
1135         <a name="_sub20" href="#_subfunctions" class="code">function [alldims] = get_all_used_dims(obj)</a>
1136         <span class="comment">% returns dimensions in obj.dims which are used by model</span>
1137         <span class="comment">% factors. Models used by GCTF models may have dims listed</span>
1138         <span class="comment">% in obj.dims which are not used by any one of the factors</span>
1139             alldims = [];
1140             <span class="keyword">for</span> di = 1:length(obj.dims)
1141                 found = false;
1142                 <span class="keyword">for</span> fi = 1:length(obj.factors)
1143                     <span class="keyword">if</span> obj.factors(fi).got_dimension(obj.dims(di))
1144                         found = true;
1145                         <span class="keyword">break</span>;
1146                     <span class="keyword">end</span>
1147                 <span class="keyword">end</span>
1148                 <span class="keyword">if</span> found
1149                     alldims = [ alldims obj.dims(di) ];
1150                 <span class="keyword">end</span>
1151             <span class="keyword">end</span>
1152         <span class="keyword">end</span>
1153 
1154 
1155 
1156         <a name="_sub21" href="#_subfunctions" class="code">function [contract_dims] = get_contraction_dims(obj)</a>
1157         <span class="comment">% returns cell of dimensions which must be contracted to</span>
1158         <span class="comment">% calculate output factor(s)</span>
1159 
1160             output_chars = {};
1161             <span class="keyword">for</span> f=1:length(obj.factors)
1162                 <span class="keyword">if</span> obj.factors(f).isObserved
1163 
1164                     <span class="comment">% for each dimension of this factor</span>
1165                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
1166                         output_chars = [output_chars <span class="keyword">...</span>
1167                                         obj.factors(f).dims(i).name];
1168                     <span class="keyword">end</span>
1169 
1170                 <span class="keyword">end</span>
1171             <span class="keyword">end</span>
1172 
1173             <span class="comment">% contraction dimensions: alldims - output_dims</span>
1174             <span class="comment">% alldims was obj.dims but now it is not due to GCTF</span>
1175             <span class="comment">% usage which may cause obj.dims to include dims not</span>
1176             <span class="comment">% included in the model, now we must calculate alldims</span>
1177             alldims = obj.get_all_used_dims();
1178 
1179             contract_dims={};
1180             <span class="keyword">for</span> d_a = 1:length(alldims)
1181                 found=0;
1182                 <span class="keyword">for</span> d_o = 1:length(output_chars)
1183                     <span class="keyword">if</span> alldims(d_a) == char(output_chars(d_o))
1184                         found=1;
1185                         <span class="keyword">break</span>
1186                     <span class="keyword">end</span>
1187                 <span class="keyword">end</span>
1188 
1189                 <span class="keyword">if</span> found == 0
1190                     contract_dims = [contract_dims alldims(d_a)];
1191                     <span class="comment">%['add '  alldims(d_a).name]</span>
1192                 <span class="keyword">end</span>
1193             <span class="keyword">end</span>
1194 
1195             <span class="comment">%['return ' contract_dims.name]</span>
1196             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
1197         <span class="keyword">end</span>
1198 
1199 
1200 
1201 
1202         <a name="_sub22" href="#_subfunctions" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a>
1203         <span class="comment">% returns cell of TFDimensions which must be contracted to</span>
1204         <span class="comment">% calculate output factor(s) by using current factors to</span>
1205         <span class="comment">% calculate all dimension not model.dims. (model.dims is always</span>
1206         <span class="comment">% fixed to maximum possible dimension list.)</span>
1207 
1208             output_chars = {};
1209             <span class="keyword">for</span> f=1:length(obj.factors)
1210                 <span class="keyword">if</span> obj.factors(f).isObserved
1211 
1212                     <span class="comment">% for each dimension of this factor</span>
1213                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
1214                         output_chars = [output_chars <span class="keyword">...</span>
1215                                         obj.factors(f).dims(i).name];
1216                     <span class="keyword">end</span>
1217 
1218                 <span class="keyword">end</span>
1219             <span class="keyword">end</span>
1220 
1221             <span class="comment">% contraction dimensions: alldims - output_dims</span>
1222             alldims={};
1223             <span class="keyword">for</span> f = 1:length(obj.factors)
1224                 <span class="keyword">for</span> d = 1:length(obj.factors(f).dims)
1225                     found = 0;
1226                     n=obj.factors(f).dims(d).name;
1227                     <span class="keyword">for</span> i=1:length(alldims)
1228                         <span class="keyword">if</span> char(alldims(i)) == n
1229                             found = 1;
1230                             <span class="keyword">break</span>
1231                         <span class="keyword">end</span>
1232                     <span class="keyword">end</span>
1233 
1234                     <span class="keyword">if</span> ~found
1235                         alldims = [alldims n];
1236                     <span class="keyword">end</span>
1237                 <span class="keyword">end</span>
1238             <span class="keyword">end</span>
1239 
1240             contract_dims={};
1241             <span class="keyword">for</span> d_a = 1:length(alldims)
1242                 found=0;
1243                 <span class="keyword">for</span> d_o = 1:length(output_chars)
1244                     <span class="keyword">if</span> char(alldims(d_a)) == char(output_chars(d_o))
1245                         found=1;
1246                         <span class="keyword">break</span>
1247                     <span class="keyword">end</span>
1248                 <span class="keyword">end</span>
1249 
1250                 <span class="keyword">if</span> found == 0
1251                     contract_dims = [contract_dims alldims(d_a)];
1252                     <span class="comment">%['add '  alldims(d_a).name]</span>
1253                 <span class="keyword">end</span>
1254             <span class="keyword">end</span>
1255 
1256             <span class="comment">%['return ' contract_dims.name]</span>
1257             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
1258         <span class="keyword">end</span>
1259 
1260 
1261 
1262 
1263         <a name="_sub23" href="#_subfunctions" class="code">function [factor_inds] = latent_factor_indices(obj)</a>
1264             factor_inds=[];
1265             <span class="keyword">for</span> f=1:length(obj.factors)
1266                 <span class="keyword">if</span> obj.factors(f).isLatent
1267                     factor_inds = [ factor_inds f ];
1268                 <span class="keyword">end</span>
1269             <span class="keyword">end</span>
1270         <span class="keyword">end</span>
1271 
1272 
1273 
1274 
1275         <a name="_sub24" href="#_subfunctions" class="code">function [factors] = latent_factors(obj)</a>
1276             factors=[];
1277             <span class="keyword">for</span> f=1:length(obj.factors)
1278                 <span class="keyword">if</span> obj.factors(f).isLatent
1279                     factors = [ factors obj.factors(f) ];
1280                 <span class="keyword">end</span>
1281             <span class="keyword">end</span>
1282         <span class="keyword">end</span>
1283 
1284 
1285 
1286 
1287         <a name="_sub25" href="#_subfunctions" class="code">function [factor_ind] = observed_factor_index(obj)</a>
1288             factor_ind=0;
1289             <span class="keyword">for</span> f=1:length(obj.factors)
1290                 <span class="keyword">if</span> obj.factors(f).isObserved
1291                     factor_ind = f;
1292                     <span class="keyword">return</span>
1293                 <span class="keyword">end</span>
1294             <span class="keyword">end</span>
1295         <span class="keyword">end</span>
1296 
1297 
1298 
1299 
1300         <a name="_sub26" href="#_subfunctions" class="code">function [factor] = observed_factor(obj)</a>
1301         <span class="comment">% returns first observed factor (useful for PLTF operations)</span>
1302             <span class="keyword">for</span> f=1:length(obj.factors)
1303                 <span class="keyword">if</span> obj.factors(f).isObserved
1304                     factor = obj.factors(f);
1305                     <span class="keyword">return</span>
1306                 <span class="keyword">end</span>
1307             <span class="keyword">end</span>
1308         <span class="keyword">end</span>
1309 
1310 
1311 
1312 
1313         <a name="_sub27" href="#_subfunctions" class="code">function [factors] = observed_factors(obj)</a>
1314             factors=[];
1315             <span class="keyword">for</span> f=1:length(obj.factors)
1316                 <span class="keyword">if</span> obj.factors(f).isObserved
1317                     factors = [ factors obj.factors(f) ];
1318                 <span class="keyword">end</span>
1319             <span class="keyword">end</span>
1320         <span class="keyword">end</span>
1321 
1322 
1323 
1324 
1325         <a name="_sub28" href="#_subfunctions" class="code">function [factors] = input_factors(obj)</a>
1326             factors=[];
1327             <span class="keyword">for</span> f=1:length(obj.factors)
1328                 <span class="keyword">if</span> obj.factors(f).isInput
1329                     factors = [ factors obj.factors(f) ];
1330                 <span class="keyword">end</span>
1331             <span class="keyword">end</span>
1332         <span class="keyword">end</span>
1333 
1334 
1335 
1336 
1337         <a name="_sub29" href="#_subfunctions" class="code">function [factors] = temp_factors(obj)</a>
1338             factors=[];
1339             <span class="keyword">for</span> f=1:length(obj.factors)
1340                 <span class="keyword">if</span> obj.factors(f).isTemp
1341                     factors = [ factors obj.factors(f) ];
1342                 <span class="keyword">end</span>
1343             <span class="keyword">end</span>
1344         <span class="keyword">end</span>
1345 
1346 
1347 
1348 
1349         <a name="_sub30" href="#_subfunctions" class="code">function [index] = get_factor_index(obj, factor)</a>
1350         <span class="comment">% returns index of a factor in factor list</span>
1351         <span class="comment">% if factor does not exist returns 0</span>
1352             index = 0;
1353             <span class="keyword">for</span> f = 1:length(obj.factors)
1354                 <span class="keyword">if</span> factor == obj.factor(f)
1355                     index = f;
1356                     <span class="keyword">break</span>;
1357                 <span class="keyword">end</span>
1358             <span class="keyword">end</span>
1359         <span class="keyword">end</span>
1360 
1361 
1362 
1363 
1364         <a name="_sub31" href="#_subfunctions" class="code">function [name] = get_factor_data_name(obj, index)</a>
1365         <span class="comment">% returns global data name of the factor at index of</span>
1366         <span class="comment">% factors TFFactor array. index may be an TFFactor instance.</span>
1367         <span class="comment">%</span>
1368         <span class="comment">% To preserve model elements' data, their naming structure</span>
1369         <span class="comment">% is different than temporary factors. Model data elements</span>
1370         <span class="comment">% use TFFactor.get_data_name whereas temporary elements use</span>
1371         <span class="comment">% PLTFModel.get_coded_factor_name. This it is possible to</span>
1372         <span class="comment">% re-use memory structures with same dimensions</span>
1373             <span class="keyword">if</span> isa(index, <span class="string">'TFFactor'</span>)
1374                 factor = index;
1375             <span class="keyword">elseif</span> isnumeric(index)
1376                 factor = obj.factors(index);
1377             <span class="keyword">end</span>
1378 
1379             <span class="keyword">if</span> factor.isTemp
1380                 name = obj.get_coded_factor_name(factor);
1381             <span class="keyword">else</span>
1382                 <span class="comment">% assume we have model element</span>
1383                 name = factor.get_data_name();
1384             <span class="keyword">end</span>
1385         <span class="keyword">end</span>
1386 
1387 
1388         <a name="_sub32" href="#_subfunctions" class="code">function [code_name] = get_coded_factor_name(obj, index)</a>
1389         <span class="comment">% returns coded name of the factor at index, used</span>
1390         <span class="comment">% index may be a factor, in which case factor does not need</span>
1391         <span class="comment">% to exist in obj.factors</span>
1392         <span class="comment">% internally for detecting data using same dimensions</span>
1393         <span class="comment">% used with temporary factors in order to re-use same</span>
1394         <span class="comment">% dimension data structures</span>
1395 
1396             <span class="keyword">if</span> isnumeric(index)
1397                 dims = obj.factors(index).dims;
1398             <span class="keyword">elseif</span> isa(index, <span class="string">'TFFactor'</span>)
1399                 dims = index.dims;
1400             <span class="keyword">end</span>
1401 
1402             code_name = [<span class="string">'factor_'</span> <span class="keyword">...</span>
1403                 char(obj.order_dims(TFDimensionList2cell(dims)))'];
1404         <span class="keyword">end</span>
1405 
1406 
1407 
1408         <a name="_sub33" href="#_subfunctions" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a>
1409 
1410             <span class="keyword">if</span> ~strcmp(type, <span class="string">'all'</span>) &amp;&amp; ~strcmp(type, <span class="string">'nonClamped'</span>)
1411                 throw(MException(<span class="string">'PLTFModel:WrongInitType'</span>, <span class="keyword">...</span>
1412                                  [<span class="string">'Supported init type values: all, '</span> <span class="keyword">...</span>
1413                                   <span class="string">'nonClamped'</span>]));
1414             <span class="keyword">end</span>
1415 
1416             <span class="keyword">for</span> fi=1:length(obj.latent_factor_indices)
1417 
1418                 <span class="keyword">if</span> strcmp(type, <span class="string">'all'</span>) || <span class="keyword">...</span>
1419                         ( strcmp(type, <span class="string">'nonClamped'</span>) &amp;&amp; <span class="keyword">...</span>
1420                           obj.factors(fi).isInput == 0 )
1421 
1422                     data_name = [obj.get_factor_data_name(fi)];
1423                     
1424                     <span class="keyword">if</span> nargin==2
1425                         obj.factors(fi).rand_init(obj.dims, 100, data_name);
1426                     <span class="keyword">else</span>
1427                         obj.factors(fi).rand_init(obj.dims, imax, data_name);
1428                     <span class="keyword">end</span>
1429 
1430                 <span class="keyword">end</span>
1431             <span class="keyword">end</span>
1432 
1433         <span class="keyword">end</span>
1434 
1435 
1436 
1437 
1438         <a name="_sub34" href="#_subfunctions" class="code">function [r] = eq(a,b)</a>
1439             r = false;
1440 
1441             <span class="comment">% mark matched b factors</span>
1442             <span class="comment">% if there are any unmarked -&gt; inequal</span>
1443             <span class="comment">% problematic case:</span>
1444             <span class="comment">% a.factors ( ip, jpi ) , b.factors (  ip, pi )</span>
1445             <span class="comment">% b==a matches all b objects with a.factors(1)</span>
1446             <span class="comment">% but a~=b !</span>
1447 
1448             b_marks = zeros(size(b.factors));
1449 
1450             <span class="keyword">if</span> length(a.factors) == length(b.factors)
1451                 <span class="keyword">for</span> f_a = 1:length(a.factors)
1452                     found = 0;
1453                     <span class="keyword">for</span> f_b = 1:length(b.factors)
1454                         <span class="keyword">if</span> a.factors(f_a) == b.factors(f_b) &amp;&amp; <span class="keyword">...</span>
1455                                 b_marks(f_b) == 0
1456                             found = 1;
1457                             b_marks(f_b) = 1;
1458                             <span class="keyword">break</span>
1459                         <span class="keyword">end</span>
1460                     <span class="keyword">end</span>
1461 
1462                     <span class="keyword">if</span> found == 0
1463                         <span class="keyword">return</span>
1464                     <span class="keyword">end</span>
1465                 <span class="keyword">end</span>
1466 
1467                 r = true;
1468             <span class="keyword">end</span>
1469         <span class="keyword">end</span>
1470 
1471 
1472 
1473 
1474         <a name="_sub35" href="#_subfunctions" class="code">function [] = full_pltf_mem_analysis(obj)</a>
1475             obj.pltf(1, <span class="string">'full'</span>, <span class="string">'mem_analysis'</span>);
1476         <span class="keyword">end</span>
1477 
1478 
1479 
1480 
1481         <a name="_sub36" href="#_subfunctions" class="code">function [] = optimal_pltf_mem_analysis(obj)</a>
1482             obj.pltf(1, <span class="string">'optimal'</span>, <span class="string">'mem_analysis'</span>);
1483         <span class="keyword">end</span>
1484 
1485 
1486 
1487 
1488     <span class="keyword">end</span>
1489 
1490 
1491 
1492 
1493 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 18-Oct-2012 00:58:26 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>