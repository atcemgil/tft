<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of TFModel</title>
  <meta name="keywords" content="TFModel">
  <meta name="description" content="Represents data required to describe a tensor factorization model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html tft -->
<h1>TFModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Represents data required to describe a tensor factorization model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Represents data required to describe a tensor factorization model

   A model is represented with its name and factors array of
   TFFactor objects. dims array of TFDimension objects define
   dimensions used by this model. Dimensions are transfered to C++
   in the order defined in dims array. See examples below for a
   full model description.

   Examples:
   
   dim_i = TFDimension('name', 'i', 'cardinality', 5);
   dim_j = TFDimension('cardinality', 6, 'name', 'j');
   dim_k = TFDimension('cardinality', 7, 'name', 'k');
   dim_r = TFDimension('cardinality', 10, 'name', 'r');
   
   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);
   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);
   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);
   
   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);
   
   parafac_model.rand_init_latent_factors('all');

   See also <a href="TFDimension.html" class="code" title="">TFDimension</a>, <a href="TFFactor.html" class="code" title="">TFFactor</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFDimension.html" class="code" title="">TFDimension</a>	Represents a single dimension</li><li><a href="TFFactor.html" class="code" title="">TFFactor</a>	Represents a PLTF factor</li><li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = TFModel(varargin)</a></li><li><a href="#_sub2" class="code">function [] = pltf(obj, iternum, contract_type)</a></li><li><a href="#_sub3" class="code">function [] = delta(obj, alpha, output_name, contract_type,</a></li><li><a href="#_sub4" class="code">function [r] = eq(a,b)</a></li><li><a href="#_sub5" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a></li><li><a href="#_sub6" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj)</a></li><li><a href="#_sub7" class="code">function [graph] = schedule_dp(obj)</a></li><li><a href="#_sub8" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a></li><li><a href="#_sub9" class="code">function [newmodel] = contract(obj, dim)</a></li><li><a href="#_sub10" class="code">function [obj] = update_cost_from_latent(obj)</a></li><li><a href="#_sub11" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a></li><li><a href="#_sub12" class="code">function [size] = get_element_size(obj)</a></li><li><a href="#_sub13" class="code">function [card] = get_index_card(obj, index_char)</a></li><li><a href="#_sub14" class="code">function [factor] = get_first_non_observed_factor(obj)</a></li><li><a href="#_sub15" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a></li><li><a href="#_sub16" class="code">function [ind] = find_cell_char(obj, chars)</a></li><li><a href="#_sub17" class="code">function [r] = get_dimension_index(obj, dim)</a></li><li><a href="#_sub18" class="code">function [ordered_index_chars] = order_dims(obj,</a></li><li><a href="#_sub19" class="code">function [newmodel] = contract_all(obj, contract_type)</a></li><li><a href="#_sub20" class="code">function [contract_dims] = get_contraction_dims(obj)</a></li><li><a href="#_sub21" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a></li><li><a href="#_sub22" class="code">function [factor_inds] = latent_factor_indices(obj)</a></li><li><a href="#_sub23" class="code">function [factors] = latent_factors(obj)</a></li><li><a href="#_sub24" class="code">function [factor_ind] = observed_factor_index(obj)</a></li><li><a href="#_sub25" class="code">function [factor] = observed_factor(obj)</a></li><li><a href="#_sub26" class="code">function [factors] = observed_factors(obj)</a></li><li><a href="#_sub27" class="code">function [factors] = input_factors(obj)</a></li><li><a href="#_sub28" class="code">function [factors] = temp_factors(obj)</a></li><li><a href="#_sub29" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Represents data required to describe a tensor factorization model</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%   A model is represented with its name and factors array of</span>
0004 <span class="comment">%   TFFactor objects. dims array of TFDimension objects define</span>
0005 <span class="comment">%   dimensions used by this model. Dimensions are transfered to C++</span>
0006 <span class="comment">%   in the order defined in dims array. See examples below for a</span>
0007 <span class="comment">%   full model description.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   Examples:</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   dim_i = TFDimension('name', 'i', 'cardinality', 5);</span>
0012 <span class="comment">%   dim_j = TFDimension('cardinality', 6, 'name', 'j');</span>
0013 <span class="comment">%   dim_k = TFDimension('cardinality', 7, 'name', 'k');</span>
0014 <span class="comment">%   dim_r = TFDimension('cardinality', 10, 'name', 'r');</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);</span>
0017 <span class="comment">%   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);</span>
0018 <span class="comment">%   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%   parafac_model.rand_init_latent_factors('all');</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   See also TFDimension, TFFactor</span>
0025 
0026 classdef <a href="TFModel.html" class="code" title="">TFModel</a>
0027 
0028     properties
0029         name=<span class="string">''</span>;          <span class="comment">% name of the model</span>
0030         factors=<a href="TFFactor.html" class="code" title="">TFFactor</a>; <span class="comment">% array of TFFactor</span>
0031 
0032         dims=<a href="TFDimension.html" class="code" title="">TFDimension</a>; <span class="comment">% array of TFDimension used by factors defines</span>
0033                           <span class="comment">% order of dimensions on memory</span>
0034 
0035         cost=0;
0036 
0037     <span class="keyword">end</span>
0038 
0039     methods
0040 
0041         <a name="_sub0" href="#_subfunctions" class="code">function obj = TFModel(varargin)</a>
0042             p = inputParser;
0043             addParamValue(p, <span class="string">'name'</span>, <span class="string">''</span>, @isstr);
0044             addParamValue(p, <span class="string">'factors'</span>, [], @isvector);
0045             addParamValue(p, <span class="string">'dims'</span>, [], @isvector);
0046 
0047             parse(p,varargin{:});
0048 
0049             <span class="comment">% check if all dims elements are TFDimension objects</span>
0050             <span class="keyword">for</span> i = 1:length(p.Results.dims)
0051                 <span class="keyword">if</span> ~isa(p.Results.dims(i), <span class="string">'TFDimension'</span>)
0052                     err = MException( <span class="keyword">...</span>
0053                         [<span class="string">'TFModel:DimensionNotTFDimension'</span>], <span class="keyword">...</span>
0054                         [<span class="string">'Dimensions of TFModel must be '</span> <span class="keyword">...</span>
0055                          <span class="string">'TFDimension objects'</span>]);
0056                     throw(err);
0057                 <span class="keyword">end</span>
0058             <span class="keyword">end</span>
0059             obj.dims = p.Results.dims;
0060 
0061             <span class="comment">% check if all factors are TFFactor objects</span>
0062             <span class="keyword">for</span> i = 1:length(p.Results.factors)
0063                 <span class="keyword">if</span> ~isa(p.Results.factors(i), <span class="string">'TFFactor'</span>)
0064                     err = MException( <span class="keyword">...</span>
0065                         [<span class="string">'TFModel:FactorsNotTFFactor'</span>], <span class="keyword">...</span>
0066                         [<span class="string">'Factors of TFModel must be '</span> <span class="keyword">...</span>
0067                          <span class="string">'TFFactor objects'</span>]);
0068                     throw(err);
0069                 <span class="keyword">end</span>
0070             <span class="keyword">end</span>
0071             obj.factors = p.Results.factors;
0072 
0073             obj.name = p.Results.name;
0074 
0075         <span class="keyword">end</span>
0076 
0077         <a name="_sub1" href="#_subfunctions" class="code">function [] = pltf(obj, iternum, contract_type)</a>
0078         <span class="comment">% performs PLTF update operations on the model</span>
0079         <span class="comment">% returns estimated TFFactor (\hat(X))</span>
0080         <span class="comment">% iternum: number of iterations</span>
0081         <span class="comment">% contract_type: if optimal contractions are performed in</span>
0082         <span class="comment">% least memory using sequence</span>
0083         <span class="comment">% defines order of contraction operations</span>
0084 
0085             <span class="keyword">if</span> nargin == 2
0086                 contract_type = <span class="string">''</span>
0087             <span class="keyword">end</span>
0088 
0089             hat_X = obj.observed_factor;
0090             hat_X.name = <span class="string">'hat_X'</span>;
0091 
0092             eval( [ <span class="string">'global '</span> obj.observed_factor.get_data_name() <span class="keyword">...</span>
0093                     <span class="string">';'</span> ] );
0094             <span class="keyword">global</span> hat_X_data;
0095             hat_X.rand_init(obj.dims, 100);
0096 
0097             mask = obj.observed_factor;
0098             mask.name = <span class="string">'mask'</span>;
0099             <span class="keyword">global</span> mask_data;
0100             mask_data = ones(size(hat_X_data));
0101 
0102             KL=zeros(1,iternum);
0103             <span class="keyword">for</span> iter = 1:iternum
0104                 <span class="keyword">for</span> alpha=1:length(obj.latent_factor_indices)
0105                     <span class="comment">% access global data</span>
0106                     X_name = <span class="keyword">...</span>
0107                         obj.factors(obj.observed_factor_index) <span class="keyword">...</span>
0108                         .get_data_name();
0109                     eval([<span class="string">'global '</span> X_name <span class="string">';'</span>]);
0110                     Z_alpha_name = <span class="keyword">...</span>
0111                         obj.factors(alpha).get_data_name();
0112                     eval( [ <span class="string">'global '</span> Z_alpha_name <span class="string">';'</span> ] );
0113 
0114 
0115 
0116 
0117                     <span class="comment">% recalculate hat_X</span>
0118                     newmodel = obj;
0119 
0120                     <span class="keyword">if</span> iter==1 &amp;&amp; alpha==1
0121                         <span class="comment">%g = newmodel.schedule_dp();</span>
0122                         <span class="comment">%system([ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0123                         <span class="comment">%                    ' dot -o /tmp/img.eps; ' ...</span>
0124                         <span class="comment">%                    ' display  /tmp/img.eps ' ...</span>
0125                         <span class="comment">%                    ' ' ] ] );</span>
0126                     <span class="keyword">end</span>
0127 
0128                     <span class="comment">% perform contraction</span>
0129                     newmodel = newmodel.contract_all(contract_type);
0130 
0131                     <span class="comment">% store result in hat_X_data</span>
0132                     result_name = <span class="keyword">...</span>
0133                         newmodel.get_first_non_observed_factor() <span class="keyword">...</span>
0134                         .get_data_name();
0135                     eval([<span class="string">'global '</span> result_name <span class="string">';'</span>] );
0136                     eval([<span class="string">'hat_X_data = '</span> result_name <span class="string">';'</span> ] ); 
0137 
0138 
0139 
0140                     <span class="comment">% store X / hat_X in hat_X data</span>
0141                     eval( [ <span class="string">'hat_X_data  =  '</span> <span class="keyword">...</span>
0142                             X_name <span class="keyword">...</span>
0143                             <span class="string">' ./ '</span> <span class="keyword">...</span>
0144                             <span class="string">' hat_X_data ;'</span> ] );
0145 
0146 
0147                     <span class="comment">% generate D1</span>
0148                     obj.delta(alpha, <span class="string">'D1_data'</span>, contract_type, hat_X);
0149 
0150                     <span class="comment">% generate D2</span>
0151                     obj.delta(alpha, <span class="string">'D2_data'</span>, contract_type, mask);
0152 
0153                     <span class="comment">% update Z_alpha</span>
0154                     <span class="keyword">global</span> D1_data D2_data;
0155                     eval( [ Z_alpha_name <span class="string">'='</span> Z_alpha_name <span class="string">' .* '</span> <span class="keyword">...</span>
0156                             <span class="string">'D1_data'</span>                     <span class="string">' ./ '</span> <span class="keyword">...</span>
0157                             <span class="string">'D2_data ;'</span> ] );
0158 
0159 
0160                     <span class="comment">% calculate KL divergence</span>
0161                     eval ( [ <span class="string">'KL(iter) = sum(sum(sum( (hat_X_data .* '</span> X_name <span class="string">') .* '</span> <span class="keyword">...</span>
0162                              <span class="string">' (log( (hat_X_data .* '</span> X_name <span class="string">') ) - '</span> <span class="keyword">...</span>
0163                              <span class="string">'log('</span> X_name <span class="keyword">...</span>
0164                              <span class="string">') ) - (hat_X_data .* '</span> X_name <span class="string">')'</span> <span class="keyword">...</span>
0165                              <span class="string">'+ '</span> X_name <span class="keyword">...</span>
0166                              <span class="string">')));'</span> ]);
0167 
0168                 <span class="keyword">end</span>
0169             <span class="keyword">end</span>
0170             display([<span class="string">'KL divergence over iterations: '</span>]);
0171             display(KL);
0172             plot(KL);
0173             title(<span class="string">'KL divergence over iterations'</span>);
0174             xlabel(<span class="string">'iteration number'</span>);
0175             ylabel(<span class="string">'KL divergence'</span>);
0176         <span class="keyword">end</span>
0177 
0178         <a name="_sub2" href="#_subfunctions" class="code">function [] = delta(obj, alpha, output_name, contract_type, </a><span class="keyword">...</span>
0179                             A)
0180         <span class="comment">% PLTF delta function implementation</span>
0181         <span class="comment">% alpha: index of latent factor in TFModel.factors array</span>
0182         <span class="comment">% which will be updated</span>
0183         <span class="comment">% name: unique name used as the name of calculated delta</span>
0184         <span class="comment">% factor data</span>
0185         <span class="comment">% contract_type: if optimal contractions are performed in</span>
0186         <span class="comment">% least memory using sequence</span>
0187         <span class="comment">% A: operand element of delta function assumed all ones if</span>
0188         <span class="comment">% not given</span>
0189 
0190             
0191             <span class="comment">% create new model for delta operation</span>
0192             d_model = obj;
0193 
0194             <span class="comment">% remove observed factor</span>
0195             d_model.factors(d_model.observed_factor_index) = [];
0196 
0197             <span class="comment">% add Z_alpha as new observed factor</span>
0198             d_model.factors(alpha).isLatent = 0;
0199             d_model.factors(alpha).isObserved= 1;
0200 
0201             <span class="comment">% if given, add A as a new latent factor</span>
0202             <span class="keyword">if</span> nargin == 5
0203                 A.isLatent = 1;
0204                 A.isObserved = 0;
0205                 d_model.factors = [d_model.factors A];
0206             <span class="keyword">end</span>
0207 
0208 
0209             <span class="comment">%g = d_model.schedule_dp();</span>
0210             <span class="comment">%system( [ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0211             <span class="comment">%                    ' dot -o /tmp/img.eps ;  display  /tmp/img.eps; ' ] ] );</span>
0212             <span class="comment">% perform contraction</span>
0213             d_model=d_model.contract_all(contract_type);
0214 
0215             eval( [ <span class="string">'global '</span> output_name <span class="string">';'</span>] );
0216             eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0217                     d_model.get_first_non_observed_factor().get_data_name() <span class="string">';'</span><span class="keyword">...</span>
0218                   ] );
0219 
0220             eval( [ output_name <span class="string">'='</span> <span class="keyword">...</span>
0221                     d_model.get_first_non_observed_factor().get_data_name() <span class="keyword">...</span>
0222                     <span class="string">';'</span> ]);
0223         <span class="keyword">end</span>
0224 
0225         <a name="_sub3" href="#_subfunctions" class="code">function [r] = eq(a,b)</a>
0226             r = false;
0227 
0228             <span class="comment">% mark matched b factors</span>
0229             <span class="comment">% if there are any unmarked -&gt; inequal</span>
0230             <span class="comment">% problematic case:</span>
0231             <span class="comment">% a.factors ( ip, jpi ) , b.factors (  ip, pi )</span>
0232             <span class="comment">% b==a matches all b objects with a.factors(1)</span>
0233             <span class="comment">% but a~=b !</span>
0234 
0235             b_marks = zeros(size(b.factors));
0236 
0237             <span class="keyword">if</span> length(a.factors) == length(b.factors)
0238                 <span class="keyword">for</span> f_a = 1:length(a.factors)
0239                     found = 0;
0240                     <span class="keyword">for</span> f_b = 1:length(b.factors)
0241                         <span class="keyword">if</span> a.factors(f_a) == b.factors(f_b) &amp;&amp; <span class="keyword">...</span>
0242                                 b_marks(f_b) == 0
0243                             found = 1;
0244                             b_marks(f_b) = 1;
0245                             <span class="keyword">break</span>
0246                         <span class="keyword">end</span>
0247                     <span class="keyword">end</span>
0248 
0249                     <span class="keyword">if</span> found == 0
0250                         <span class="keyword">return</span>
0251                     <span class="keyword">end</span>
0252                 <span class="keyword">end</span>
0253 
0254                 r = true;
0255             <span class="keyword">end</span>
0256         <span class="keyword">end</span>
0257 
0258         <a name="_sub4" href="#_subfunctions" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a>
0259         <span class="comment">% returns list of TFDimension objects representing</span>
0260         <span class="comment">% dimensions which are required to be added to the current</span>
0261         <span class="comment">% TFModel object in order to reach initial model where</span>
0262         <span class="comment">% uncontraction_dims = {}</span>
0263         <span class="comment">% Calculation is performed as follows:</span>
0264         <span class="comment">% uncontraction_dims = contraction_dims - current_contraction_dims</span>
0265 
0266             contraction_dims = obj.get_contraction_dims();
0267             current_contraction_dims = <span class="keyword">...</span>
0268                 obj.get_current_contraction_dims();
0269             uncontraction_dims = [];
0270 
0271             <span class="keyword">for</span> cdi = 1:length(contraction_dims)
0272                 found=0;
0273                 <span class="keyword">for</span> ccdi = 1:length(current_contraction_dims)
0274                     <span class="keyword">if</span> contraction_dims(cdi) == <span class="keyword">...</span>
0275                             char(current_contraction_dims(ccdi))
0276                         found=1;
0277                         <span class="keyword">break</span>;
0278                     <span class="keyword">end</span>
0279                 <span class="keyword">end</span>
0280                 <span class="keyword">if</span> ~found
0281                     uncontraction_dims = [ uncontraction_dims <span class="keyword">...</span>
0282                                         contraction_dims(cdi) ];
0283                 <span class="keyword">end</span>
0284             <span class="keyword">end</span>
0285         <span class="keyword">end</span>
0286 
0287         <a name="_sub5" href="#_subfunctions" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj)</a>
0288         <span class="comment">% Runs schedule_dp function to generate graph with least</span>
0289         <span class="comment">% memory using contraction sequence information in it. Then</span>
0290         <span class="comment">% searches TFGraph.optimal_edges for the optimal path and</span>
0291         <span class="comment">% returns a cell of contraction dimension names.</span>
0292 
0293             graph = obj.schedule_dp();
0294             t = graph.optimal_edges;
0295             t(t==0) = Inf;
0296             ocs_models = [];
0297             i = length(t);
0298             <span class="keyword">while</span> i ~= 1
0299                 ocs_models = [ ocs_models graph.node_list(i) ];
0300                 i = find( t(:,i) == min(t(:, i)) );
0301             <span class="keyword">end</span>
0302             ocs_models = [ ocs_models graph.node_list(i) ];
0303 
0304             ocs_dims = {};
0305             <span class="keyword">for</span> i = 1:(length(ocs_models)-1)
0306                 ocs_dims = [ ocs_dims <span class="keyword">...</span>
0307                              { setdiff( <span class="keyword">...</span>
0308                                  ocs_models(i)<span class="keyword">...</span>
0309                                  .get_current_contraction_dims, <span class="keyword">...</span>
0310                                  ocs_models(i+ <span class="keyword">...</span>
0311                                             1)<span class="keyword">...</span>
0312                                  .get_current_contraction_dims) }; <span class="keyword">...</span>
0313                            ];
0314             <span class="keyword">end</span>
0315 
0316         <span class="keyword">end</span>
0317             
0318 
0319         <a name="_sub6" href="#_subfunctions" class="code">function [graph] = schedule_dp(obj)</a>
0320         <span class="comment">% returns a tree of TFModel generated as a result of the</span>
0321         <span class="comment">% search for least memory consuming contraction sequence</span>
0322         <span class="comment">% with a dynamic programming approach</span>
0323 
0324             output_dims = obj.get_contraction_dims();
0325             contraction_dims = obj.get_contraction_dims();
0326             
0327             <span class="comment">% generate final state of contraction operation to be</span>
0328             <span class="comment">% used as the initial state of dp search</span>
0329             end_node = obj.contract_all(); <span class="comment">% must not be optimal,</span>
0330                                            <span class="comment">% infinite loop!</span>
0331 
0332             graph = <a href="TFGraph.html" class="code" title="">TFGraph</a>;
0333             process_nodes = [end_node];
0334             processing_node = 1;
0335 
0336             <span class="keyword">while</span> length(process_nodes) &gt;= processing_node
0337                 cur_node = process_nodes(processing_node);
0338                 cur_node = cur_node.update_cost_from_latent();
0339 
0340                 <span class="comment">% init graph.node_list</span>
0341                 <span class="keyword">if</span> length(graph.node_list) == 0
0342                     graph.node_list = [cur_node];
0343                     graph=graph.clear_edges();
0344                 <span class="keyword">end</span>
0345 
0346                 uncontraction_dims = cur_node.get_uncontraction_dims();
0347                 <span class="keyword">for</span> udi = 1:length(uncontraction_dims)
0348                     new_node = cur_node.uncontract(obj, <span class="keyword">...</span>
0349                                                    uncontraction_dims(udi));
0350                     new_node = new_node.update_cost_from_latent();
0351 
0352                     <span class="comment">% memoization</span>
0353                     nnidx = graph.exists(new_node);
0354                     <span class="keyword">if</span> nnidx
0355                         graph = graph.update_node(cur_node, new_node, nnidx);
0356                     <span class="keyword">else</span>
0357                         graph = graph.append_node(cur_node, new_node);
0358                         process_nodes = [ process_nodes new_node ];
0359                     <span class="keyword">end</span>
0360                 <span class="keyword">end</span>
0361 
0362                 processing_node = processing_node + 1;
0363 
0364             <span class="keyword">end</span>
0365 
0366         <span class="keyword">end</span>
0367 
0368 
0369         <a name="_sub7" href="#_subfunctions" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a>
0370         <span class="comment">% returns a new TFModel generated by adding given</span>
0371         <span class="comment">% TFDimension object dim to the model.</span>
0372         <span class="comment">% dim: TFDimension object to uncontract</span>
0373         <span class="comment">% orig_model: provides original non-contracted model data</span>
0374 
0375             newmodel = obj;
0376 
0377             newmodel.name = [ newmodel.name  <span class="keyword">...</span>
0378                               <span class="string">'_uncontract_'</span> dim.name ];
0379 
0380             uncontract_dims = obj.get_uncontraction_dims();
0381             other_dims = []; <span class="comment">% already contracted dimensions</span>
0382             <span class="keyword">for</span> i=1:length(uncontract_dims)
0383                 <span class="keyword">if</span> uncontract_dims(i) ~= dim
0384                     other_dims = [ other_dims <span class="keyword">...</span>
0385                                    uncontract_dims(i) ];
0386                 <span class="keyword">end</span>
0387             <span class="keyword">end</span>
0388 
0389             <span class="comment">% reset newmodel's factors</span>
0390             newmodel.factors = [];
0391 
0392             <span class="comment">% stores factors which will contribute to the temporary</span>
0393             <span class="comment">% factor</span>
0394             tmp_factor_parents = [];
0395 
0396 
0397             <span class="comment">% populate newmode.factors with factors independant</span>
0398             <span class="comment">% from uncontraction operation</span>
0399             <span class="keyword">for</span> fi = 1:length(orig_model.factors)
0400                 found = 0;
0401                 <span class="keyword">for</span> fdi = 1:length(orig_model.factors(fi).dims)
0402                     <span class="keyword">for</span> odi = 1:length(other_dims)
0403                         <span class="comment">% if any factor contains any one of the</span>
0404                         <span class="comment">% other_dims can not use it as it is, must</span>
0405                         <span class="comment">% create a temporary factor for those</span>
0406                         <span class="comment">% here we identify factors we will use</span>
0407                         <span class="comment">% without modification</span>
0408 
0409                         <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0410                                 orig_model.factors(fi).dims(fdi)
0411                             found=1;
0412                             <span class="keyword">break</span>
0413                         <span class="keyword">end</span>
0414                     <span class="keyword">end</span>
0415                     <span class="keyword">if</span> found, <span class="keyword">break</span>; <span class="keyword">end</span>
0416                 <span class="keyword">end</span>
0417 
0418                 <span class="keyword">if</span> ~found
0419                     <span class="comment">% if other_dims are not found in this factor then</span>
0420                     <span class="comment">% use this factor as it is in the new node</span>
0421 
0422                     newmodel.factors = [newmodel.factors <span class="keyword">...</span>
0423                                         orig_model.factors(fi) ];
0424                 <span class="keyword">else</span>
0425                     <span class="comment">% in other case this factor will be inspected</span>
0426                     <span class="comment">% further to generate temporary factor</span>
0427                     tmp_factor_parents = [ tmp_factor_parents <span class="keyword">...</span>
0428                                         orig_model.factors(fi) ];
0429                 <span class="keyword">end</span>
0430             <span class="keyword">end</span>
0431 
0432             <span class="comment">% make sure factors are unique</span>
0433             <span class="comment">%newmodel.factors = unique(newmodel.factors);</span>
0434 
0435             <span class="comment">% inspect tmp_factor_parents and generate a temporary</span>
0436             <span class="comment">% model</span>
0437             tmpf = <a href="TFFactor.html" class="code" title="">TFFactor</a>;
0438             tmpf.isTemp = 1;
0439             tmpf.name = <span class="string">'tmp'</span>;
0440             names={};
0441             tmpf.dims = [];
0442 
0443             <span class="comment">% add all dimensions of all parent factors</span>
0444             <span class="keyword">for</span> tfpi = 1:length(tmp_factor_parents)
0445                 <span class="keyword">for</span> di = 1:length(tmp_factor_parents(tfpi).dims)
0446                     <span class="keyword">if</span> tmp_factor_parents(tfpi).isLatent
0447                         <span class="comment">% if dimension is not one of the other_dims</span>
0448                         <span class="comment">% then add it to the temporary factor</span>
0449                         found = 0;
0450                         <span class="keyword">for</span> odi = 1:length(other_dims)
0451                             <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0452                                     tmp_factor_parents(tfpi).dims(di)
0453                                 found = 1;
0454                                 <span class="keyword">break</span>;
0455                             <span class="keyword">end</span>
0456                         <span class="keyword">end</span>
0457 
0458 
0459                         <span class="keyword">if</span> ~found
0460                             <span class="comment">% if not already added</span>
0461                             found2 = 0;
0462                             <span class="keyword">for</span> tmpfdind = 1:length(tmpf.dims)
0463                                 <span class="keyword">if</span> tmpf.dims(tmpfdind) == <span class="keyword">...</span>
0464                                         tmp_factor_parents(tfpi).dims(di)
0465                                     found2 = 1;
0466                                     <span class="keyword">break</span>;
0467                                 <span class="keyword">end</span>
0468                             <span class="keyword">end</span>
0469 
0470                             <span class="keyword">if</span> ~found2
0471 
0472                                 tmpf.dims = [ tmpf.dims <span class="keyword">...</span>
0473                                               tmp_factor_parents(tfpi) <span class="keyword">...</span>
0474                                               .dims(di)];
0475                                 names = [ names <span class="keyword">...</span>
0476                                           tmp_factor_parents(tfpi) <span class="keyword">...</span>
0477                                           .dims(di).name];
0478                             <span class="keyword">end</span>
0479                         <span class="keyword">end</span>
0480                     <span class="keyword">end</span>
0481                 <span class="keyword">end</span>
0482             <span class="keyword">end</span>
0483 
0484             <span class="comment">% if no names are found then there is no temporary</span>
0485             <span class="comment">% factor added</span>
0486             <span class="keyword">if</span> length(names)
0487                 <span class="comment">% make sure tmp.factor dims are unique</span>
0488                 <span class="comment">%'Ã¶nce'</span>
0489                 <span class="comment">%tmpf.dims.name</span>
0490                 <span class="comment">%tmpf.dims = unique(tmpf.dims);</span>
0491                 <span class="comment">%'sonra'</span>
0492                 <span class="comment">%tmpf.dims.name</span>
0493                 
0494                 names=obj.order_dims(unique(names));
0495                 <span class="keyword">for</span> d = 1:length(names)
0496                     tmpf.name = [ tmpf.name <span class="string">'_'</span> char(names(d)) ];
0497                 <span class="keyword">end</span>
0498                 <span class="comment">%tmpf.name = [tmpf.name '_minus_' ? ];</span>
0499                 
0500                 newmodel.factors = [ newmodel.factors tmpf ];
0501 
0502                 newmodel = newmodel.update_cost_from_latent();
0503             <span class="keyword">end</span>
0504 
0505         <span class="keyword">end</span>
0506 
0507         <a name="_sub8" href="#_subfunctions" class="code">function [newmodel] = contract(obj, dim)</a>
0508         <span class="comment">% returns a new TFModel generated by contracting obj with</span>
0509         <span class="comment">% dim which may add new temporary factors.</span>
0510         <span class="comment">% dim: TFDimension or char array or cell with the name of</span>
0511         <span class="comment">% the dimension</span>
0512 
0513             <span class="keyword">if</span> isa(dim, <span class="string">'TFDimension'</span>)
0514                 dim = dim.name;
0515             <span class="keyword">elseif</span> isa(dim, <span class="string">'cell'</span>)
0516                 dim = char(dim{1});
0517             <span class="keyword">elseif</span> ~isa(dim, <span class="string">'char'</span>)
0518                 display([<span class="string">'ERROR: unsupported dim type '</span> class(dim) <span class="keyword">...</span>
0519                          <span class="string">'was expecting TFDimension, cell or char '</span> <span class="keyword">...</span>
0520                          <span class="string">'array'</span>]);
0521                 <span class="keyword">return</span>
0522             <span class="keyword">end</span>
0523 
0524             newmodel = obj;
0525             newmodel.name = [obj.name <span class="string">'_'</span> dim];
0526 
0527             <span class="comment">% remove dim from the new model's factors'</span>
0528             contracted_factor_inds = [];
0529             <span class="keyword">for</span> f = 1:length(newmodel.factors)
0530                 <span class="keyword">if</span> ~newmodel.factors(f).isObserved
0531                     ind = <span class="keyword">...</span>
0532                         newmodel.factors(f).got_dimension(char(dim));
0533                     
0534                     <span class="keyword">if</span> ind ~= 0
0535                         <span class="comment">% remove this dimension from this factor</span>
0536                         newmodel.factors(f).dims(ind) = [];
0537 
0538                         contracted_factor_inds = <span class="keyword">...</span>
0539                             [ contracted_factor_inds f ];
0540                     <span class="keyword">end</span>
0541                 <span class="keyword">end</span>
0542             <span class="keyword">end</span>
0543 
0544             <span class="comment">% add a temporary factor including dimensions of</span>
0545             <span class="comment">% contracted factors other than contracted dimension</span>
0546             tmp=<a href="TFFactor.html" class="code" title="">TFFactor</a>;
0547             tmp.isTemp = 1;
0548             tmp.name = <span class="string">'tmp'</span>;
0549             names={};
0550             
0551             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0552                 <span class="comment">% for each dimension of the contracted factor</span>
0553                 <span class="keyword">for</span> cfi_dim = 1:length(newmodel.factors(contracted_factor_inds(cfii)).dims)
0554                     found=0;
0555                     <span class="keyword">for</span> ti = 1:length(tmp.dims)
0556                         <span class="keyword">if</span> tmp.dims(ti) == <span class="keyword">...</span>
0557                                 newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim)
0558                             found=1;
0559                             <span class="keyword">break</span>;
0560                         <span class="keyword">end</span>
0561                     <span class="keyword">end</span>
0562                     <span class="keyword">if</span> found == 0
0563                         tmp.dims = [tmp.dims <span class="keyword">...</span>
0564                                     newmodel.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0565                                     .dims(cfi_dim)];
0566                         names=[names <span class="keyword">...</span>
0567                               newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name];
0568                         <span class="comment">%display(['added from factor index' ...</span>
0569                         <span class="comment">%         contracted_factor_inds(cfii)])</span>
0570                         <span class="comment">%display(['added from factor' newmodel.factors(contracted_factor_inds(cfii)).name])</span>
0571                         <span class="comment">%display(['addd dim' char(newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name)])</span>
0572                     <span class="keyword">end</span>
0573                 <span class="keyword">end</span>
0574             <span class="keyword">end</span>
0575             names=unique(names);
0576             <span class="keyword">for</span> d = 1:length(names)
0577                 tmp.name = [tmp.name <span class="string">'_'</span> char(names(d))];
0578             <span class="keyword">end</span>
0579             tmp.name = [tmp.name <span class="string">'_minus_'</span> dim];
0580 
0581 
0582 
0583 
0584             eval( [ <span class="string">'global '</span> tmp.get_data_name()  <span class="string">';'</span>] );
0585 
0586             <span class="keyword">if</span> length(contracted_factor_inds) == 1
0587                 <span class="comment">% no multiplication</span>
0588                 eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0589                         obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0590                         .get_data_name() <span class="string">';'</span>] );
0591                 eval( [ tmp.get_data_name() <span class="string">' = '</span> <span class="keyword">...</span>
0592                         obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0593                         .get_data_name() <span class="string">';'</span>] );
0594             <span class="keyword">else</span>
0595 
0596                 <span class="comment">% multiply first two into tmp data</span>
0597                 eval( [ <span class="string">'global'</span> <span class="keyword">...</span>
0598                         <span class="string">' '</span> obj.factors(contracted_factor_inds(1)).get_data_name() <span class="keyword">...</span>
0599                         <span class="string">' '</span> obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">';'</span>] );
0600 
0601                 eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0602                         obj.factors(contracted_factor_inds(1)).get_data_name() <span class="string">', '</span><span class="keyword">...</span>
0603                         obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">');'</span> <span class="keyword">...</span>
0604                       ] );
0605 
0606                 <span class="comment">% multiply tmp data with other factors</span>
0607                 <span class="keyword">for</span> cfii = 3:length(contracted_factor_inds)
0608                     eval( [ <span class="string">'global '</span><span class="keyword">...</span>
0609                             obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0610                             .get_data_name() <span class="string">';'</span>] );
0611                     eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0612                             tmp.get_data_name() <span class="string">','</span><span class="keyword">...</span>
0613                             obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0614                             .get_data_name() <span class="string">');'</span> ] );
0615                 <span class="keyword">end</span>
0616             <span class="keyword">end</span>
0617 
0618 
0619             <span class="comment">% sum contraction dimensions on tmp data</span>
0620             
0621             con_dim_index = obj.get_dimension_index(dim);
0622 
0623             eval( [ tmp.get_data_name() <span class="string">' = sum( '</span> <span class="keyword">...</span>
0624                     tmp.get_data_name() <span class="string">', '</span> <span class="keyword">...</span>
0625                     num2str(con_dim_index) <span class="string">');'</span>] );
0626             
0627             newmodel.factors = [newmodel.factors tmp];
0628 
0629 
0630             <span class="comment">% remove contracted factors</span>
0631             <span class="comment">% other dimensions live within the tmp factor</span>
0632             removed_num=0; <span class="comment">% removal breaks loop index</span>
0633             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0634                 newmodel.factors(contracted_factor_inds(cfii) <span class="keyword">...</span>
0635                                  - removed_num) = [];
0636                 removed_num = removed_num + 1;
0637             <span class="keyword">end</span>
0638         <span class="keyword">end</span>
0639 
0640 
0641         <a name="_sub9" href="#_subfunctions" class="code">function [obj] = update_cost_from_latent(obj)</a>
0642             obj.cost = 0;
0643             lfi=obj.latent_factor_indices();
0644             <span class="keyword">for</span> fi = 1:length(lfi)
0645                 obj.cost = obj.cost + <span class="keyword">...</span>
0646                     obj.factors(lfi(fi)).get_element_size();
0647             <span class="keyword">end</span>
0648         <span class="keyword">end</span>
0649 
0650 
0651         <a name="_sub10" href="#_subfunctions" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a>
0652         <span class="comment">% returns a string to be used by fgplot</span>
0653 
0654         <span class="comment">% add dimension nodes</span>
0655             dn = [ <span class="string">'[ '''</span> ];
0656             <span class="keyword">for</span> i =1:length(obj.dims)
0657                 <span class="keyword">if</span> i ~= 1
0658                     dn = [ dn <span class="string">''','''</span> ];
0659                 <span class="keyword">end</span>
0660                 dn = [ dn obj.dims(i).name ];
0661             <span class="keyword">end</span>
0662             dn = [ dn <span class="string">''' ] '</span> ];
0663 
0664             <span class="comment">% add factor nodes</span>
0665             fn = [ <span class="string">'[ '''</span> ];
0666             <span class="keyword">for</span> i =1:length(obj.factors)
0667                 <span class="keyword">if</span> i ~= 1
0668                     fn = [ fn <span class="string">''','''</span> ];
0669                 <span class="keyword">end</span>
0670                 fn = [ fn obj.factors(i).name ];
0671             <span class="keyword">end</span>
0672             fn = [ fn <span class="string">''' ] '</span> ];
0673 
0674             <span class="comment">% add edges</span>
0675             all_edges=[<span class="string">'[ '</span> ];
0676             <span class="keyword">for</span> d = 1:length(obj.dims)
0677                 <span class="keyword">if</span> d ~= 1
0678                     all_edges = [ all_edges <span class="string">' , '</span> ];
0679                 <span class="keyword">end</span>
0680 
0681                 edges=[<span class="string">'[ '</span> ];
0682 
0683                 <span class="comment">% include this dimension if a factor uses it</span>
0684                 <span class="keyword">for</span> f = 1:length(obj.factors)
0685                     <span class="keyword">for</span> fd = 1:length(obj.factors(f).dims)
0686                         <span class="keyword">if</span> obj.factors(f).dims(fd) == obj.dims(d)
0687                             <span class="keyword">if</span> length(edges) ~= 2
0688                                 edges = [ edges <span class="string">''','''</span> ];
0689                             <span class="keyword">else</span>
0690                                 edges = [ edges <span class="string">''''</span> ];
0691                             <span class="keyword">end</span>
0692                             edges = [ edges obj.factors(f).name ];
0693                         <span class="keyword">end</span>
0694                     <span class="keyword">end</span>
0695                 <span class="keyword">end</span>
0696 
0697                 all_edges = [ all_edges edges <span class="string">''' ]'</span> ];
0698             <span class="keyword">end</span>
0699             all_edges = [ all_edges <span class="string">' ]'</span> ];
0700         <span class="keyword">end</span>
0701 
0702         <a name="_sub11" href="#_subfunctions" class="code">function [size] = get_element_size(obj)</a>
0703         <span class="comment">% returns number of elements for this model</span>
0704             size=0;
0705             <span class="keyword">for</span> f = 1:length(obj.factors)
0706                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0707                     size = size + <span class="keyword">...</span>
0708                            obj.factors(f).get_element_size();
0709                 <span class="keyword">end</span>
0710             <span class="keyword">end</span>
0711         <span class="keyword">end</span>
0712 
0713         <a name="_sub12" href="#_subfunctions" class="code">function [card] = get_index_card(obj, index_char)</a>
0714         <span class="comment">% returns cardinality of a given name of a dimension</span>
0715             <span class="keyword">for</span> d = 1:length(obj.dims)
0716                 <span class="keyword">if</span> obj.dims(d).name == index_char
0717                     card = obj.dims(d).cardinality;
0718                     <span class="keyword">break</span>
0719                 <span class="keyword">end</span>
0720             <span class="keyword">end</span>
0721         <span class="keyword">end</span>
0722 
0723         <a name="_sub13" href="#_subfunctions" class="code">function [factor] = get_first_non_observed_factor(obj)</a>
0724         <span class="comment">% returns first non observed factor index, used to return</span>
0725         <span class="comment">% index of the output factor</span>
0726             <span class="keyword">for</span> f = 1:length(obj.factors)
0727                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0728                     factor = obj.factors(f);
0729                     <span class="keyword">return</span>
0730                 <span class="keyword">end</span>
0731             <span class="keyword">end</span>
0732         <span class="keyword">end</span>
0733 
0734         <a name="_sub14" href="#_subfunctions" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a>
0735         <span class="comment">% returns first non observed factor index, used to return</span>
0736         <span class="comment">% index of the output factor</span>
0737             <span class="keyword">for</span> f = 1:length(obj.factors)
0738                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0739                     ind = f;
0740                     <span class="keyword">return</span>
0741                 <span class="keyword">end</span>
0742             <span class="keyword">end</span>
0743         <span class="keyword">end</span>
0744 
0745         <a name="_sub15" href="#_subfunctions" class="code">function [ind] = find_cell_char(obj, chars)</a>
0746         <span class="comment">% returns index of a given char array in object's dimension array</span>
0747             <span class="keyword">for</span> ind=1:length(obj.dims)
0748                 <span class="keyword">if</span> obj.dims(ind).name == chars
0749                     <span class="keyword">return</span>
0750                 <span class="keyword">end</span>
0751             <span class="keyword">end</span>
0752             ind=0;
0753         <span class="keyword">end</span>
0754 
0755        <a name="_sub16" href="#_subfunctions" class="code">function [r] = get_dimension_index(obj, dim)</a>
0756         <span class="comment">% returns index of dimension dim in obj.dims if obj</span>
0757         <span class="comment">% contains TFDimension (or char) dim returns 0 otherwise</span>
0758 
0759             r=0;
0760             <span class="keyword">for</span> d = 1:length(obj.dims)
0761                 <span class="keyword">if</span> obj.dims(d) == dim
0762                     r=d;
0763                     <span class="keyword">break</span>;
0764                 <span class="keyword">end</span>
0765             <span class="keyword">end</span>           
0766        <span class="keyword">end</span>
0767 
0768         <a name="_sub17" href="#_subfunctions" class="code">function [ordered_index_chars] = order_dims(obj, </a><span class="keyword">...</span>
0769                                                     dims_array)
0770             <span class="comment">% order given cell of dimension names according to</span>
0771             <span class="comment">% factor.dims order</span>
0772 
0773             tmp=cell(length(dims_array), 3);
0774 
0775             tmp(:,1) = dims_array;
0776             <span class="keyword">for</span> i = 1:length(dims_array)
0777                 tmp{i,2} = obj.get_index_card(char(dims_array(i)));
0778                 tmp{i,3} = obj.find_cell_char(char(dims_array(i))); <span class="comment">% order of the index</span>
0779                                                                     <span class="comment">% in the model</span>
0780             <span class="keyword">end</span>
0781 
0782             tmp=sortrows(tmp,3); <span class="comment">% sort by the order of the model indices</span>
0783             ordered_index_chars=tmp(:,1)';
0784         <span class="keyword">end</span>
0785 
0786 
0787         <a name="_sub18" href="#_subfunctions" class="code">function [newmodel] = contract_all(obj, contract_type)</a>
0788         <span class="comment">% performs all necessary contraction operations for the</span>
0789         <span class="comment">% model. if contract_type argument is equal to 'optimal'</span>
0790         <span class="comment">% then schedule_dp() is used to find the optimal (least</span>
0791         <span class="comment">% memory using) sequence and the optimal sequence is used</span>
0792         <span class="comment">% to contract all necessary dimensions. Otherwise</span>
0793         <span class="comment">% get_contraction_dims() is used to order contraction</span>
0794         <span class="comment">% operation which does not order dimensions</span>
0795 
0796             <span class="keyword">if</span> nargin == 2 &amp;&amp; strcmp(contract_type, <span class="string">'optimal'</span>)
0797                 contract_dims = <span class="keyword">...</span>
0798                     obj.get_optimal_contraction_sequence_dims();
0799 
0800                 <span class="comment">%for i=1:length(contract_dims)</span>
0801                 <span class="comment">%    display(['optimal contracting ' ...</span>
0802                 <span class="comment">%             char(contract_dims{i})]);</span>
0803                 <span class="comment">%end</span>
0804             <span class="keyword">else</span>
0805                 contract_dims = obj.get_contraction_dims();
0806 
0807                 <span class="comment">%for i=1:length(contract_dims)</span>
0808                 <span class="comment">%    display(['contracting ' contract_dims(i).name]);</span>
0809                 <span class="comment">%end</span>
0810             <span class="keyword">end</span>
0811 
0812             newmodel = obj;
0813             <span class="keyword">for</span> i = 1:length(contract_dims)
0814                 newmodel = newmodel.contract(contract_dims(i));
0815             <span class="keyword">end</span>
0816         <span class="keyword">end</span>
0817 
0818 
0819         <a name="_sub19" href="#_subfunctions" class="code">function [contract_dims] = get_contraction_dims(obj)</a>
0820         <span class="comment">% returns cell of dimensions which must be contracted to</span>
0821         <span class="comment">% calculate output factor(s)</span>
0822 
0823             output_chars = {};
0824             <span class="keyword">for</span> f=1:length(obj.factors)
0825                 <span class="keyword">if</span> obj.factors(f).isObserved
0826 
0827                     <span class="comment">% for each dimension of this factor</span>
0828                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
0829                         output_chars = [output_chars <span class="keyword">...</span>
0830                                         obj.factors(f).dims(i).name];
0831                     <span class="keyword">end</span>
0832 
0833                 <span class="keyword">end</span>
0834             <span class="keyword">end</span>
0835 
0836             <span class="comment">% contraction dimensions: alldims - output_dims</span>
0837             contract_dims={};
0838             <span class="keyword">for</span> d_a = 1:length(obj.dims)
0839                 found=0;
0840                 <span class="keyword">for</span> d_o = 1:length(output_chars)
0841                     <span class="keyword">if</span> obj.dims(d_a) == char(output_chars(d_o))
0842                         found=1;
0843                         <span class="keyword">break</span>
0844                     <span class="keyword">end</span>
0845                 <span class="keyword">end</span>
0846 
0847                 <span class="keyword">if</span> found == 0
0848                     contract_dims = [contract_dims obj.dims(d_a)];
0849                     <span class="comment">%['add '  obj.dims(d_a).name]</span>
0850                 <span class="keyword">end</span>
0851             <span class="keyword">end</span>
0852 
0853             <span class="comment">%['return ' contract_dims.name]</span>
0854             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
0855         <span class="keyword">end</span>
0856 
0857         <a name="_sub20" href="#_subfunctions" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a>
0858         <span class="comment">% returns cell of TFDimensions which must be contracted to</span>
0859         <span class="comment">% calculate output factor(s) by using current factors to</span>
0860         <span class="comment">% calculate all dimension not model.dims. (model.dims is always</span>
0861         <span class="comment">% fixed to maximum possible dimension list.)</span>
0862 
0863             output_chars = {};
0864             <span class="keyword">for</span> f=1:length(obj.factors)
0865                 <span class="keyword">if</span> obj.factors(f).isObserved
0866 
0867                     <span class="comment">% for each dimension of this factor</span>
0868                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
0869                         output_chars = [output_chars <span class="keyword">...</span>
0870                                         obj.factors(f).dims(i).name];
0871                     <span class="keyword">end</span>
0872 
0873                 <span class="keyword">end</span>
0874             <span class="keyword">end</span>
0875 
0876             <span class="comment">% contraction dimensions: alldims - output_dims</span>
0877             alldims={};
0878             <span class="keyword">for</span> f = 1:length(obj.factors)
0879                 <span class="keyword">for</span> d = 1:length(obj.factors(f).dims)
0880                     found = 0;
0881                     n=obj.factors(f).dims(d).name;
0882                     <span class="keyword">for</span> i=1:length(alldims)
0883                         <span class="keyword">if</span> char(alldims(i)) == n
0884                             found = 1;
0885                             <span class="keyword">break</span>
0886                         <span class="keyword">end</span>
0887                     <span class="keyword">end</span>
0888 
0889                     <span class="keyword">if</span> ~found
0890                         alldims = [alldims n];
0891                     <span class="keyword">end</span>
0892                 <span class="keyword">end</span>
0893             <span class="keyword">end</span>
0894 
0895             contract_dims={};
0896             <span class="keyword">for</span> d_a = 1:length(alldims)
0897                 found=0;
0898                 <span class="keyword">for</span> d_o = 1:length(output_chars)
0899                     <span class="keyword">if</span> char(alldims(d_a)) == char(output_chars(d_o))
0900                         found=1;
0901                         <span class="keyword">break</span>
0902                     <span class="keyword">end</span>
0903                 <span class="keyword">end</span>
0904 
0905                 <span class="keyword">if</span> found == 0
0906                     contract_dims = [contract_dims alldims(d_a)];
0907                     <span class="comment">%['add '  alldims(d_a).name]</span>
0908                 <span class="keyword">end</span>
0909             <span class="keyword">end</span>
0910 
0911             <span class="comment">%['return ' contract_dims.name]</span>
0912             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
0913         <span class="keyword">end</span>
0914 
0915 
0916         <a name="_sub21" href="#_subfunctions" class="code">function [factor_inds] = latent_factor_indices(obj)</a>
0917             factor_inds=[];
0918             <span class="keyword">for</span> f=1:length(obj.factors)
0919                 <span class="keyword">if</span> obj.factors(f).isLatent
0920                     factor_inds = [ factor_inds f ];
0921                 <span class="keyword">end</span>
0922             <span class="keyword">end</span>
0923         <span class="keyword">end</span>
0924 
0925 
0926         <a name="_sub22" href="#_subfunctions" class="code">function [factors] = latent_factors(obj)</a>
0927             factors=[];
0928             <span class="keyword">for</span> f=1:length(obj.factors)
0929                 <span class="keyword">if</span> obj.factors(f).isLatent
0930                     factors = [ factors obj.factors(f) ];
0931                 <span class="keyword">end</span>
0932             <span class="keyword">end</span>
0933         <span class="keyword">end</span>
0934 
0935         <a name="_sub23" href="#_subfunctions" class="code">function [factor_ind] = observed_factor_index(obj)</a>
0936             factor_ind=0;
0937             <span class="keyword">for</span> f=1:length(obj.factors)
0938                 <span class="keyword">if</span> obj.factors(f).isObserved
0939                     factor_ind = f;
0940                     <span class="keyword">return</span>
0941                 <span class="keyword">end</span>
0942             <span class="keyword">end</span>
0943         <span class="keyword">end</span>
0944 
0945         <a name="_sub24" href="#_subfunctions" class="code">function [factor] = observed_factor(obj)</a>
0946         <span class="comment">% returns first observed factor (useful for PLTF operations)</span>
0947             <span class="keyword">for</span> f=1:length(obj.factors)
0948                 <span class="keyword">if</span> obj.factors(f).isObserved
0949                     factor = obj.factors(f);
0950                     <span class="keyword">return</span>
0951                 <span class="keyword">end</span>
0952             <span class="keyword">end</span>
0953         <span class="keyword">end</span>
0954 
0955         <a name="_sub25" href="#_subfunctions" class="code">function [factors] = observed_factors(obj)</a>
0956             factors=[];
0957             <span class="keyword">for</span> f=1:length(obj.factors)
0958                 <span class="keyword">if</span> obj.factors(f).isObserved
0959                     factors = [ factors obj.factors(f) ];
0960                 <span class="keyword">end</span>
0961             <span class="keyword">end</span>
0962         <span class="keyword">end</span>
0963 
0964         <a name="_sub26" href="#_subfunctions" class="code">function [factors] = input_factors(obj)</a>
0965             factors=[];
0966             <span class="keyword">for</span> f=1:length(obj.factors)
0967                 <span class="keyword">if</span> obj.factors(f).isInput
0968                     factors = [ factors obj.factors(f) ];
0969                 <span class="keyword">end</span>
0970             <span class="keyword">end</span>
0971         <span class="keyword">end</span>
0972 
0973         <a name="_sub27" href="#_subfunctions" class="code">function [factors] = temp_factors(obj)</a>
0974             factors=[];
0975             <span class="keyword">for</span> f=1:length(obj.factors)
0976                 <span class="keyword">if</span> obj.factors(f).isTemp
0977                     factors = [ factors obj.factors(f) ];
0978                 <span class="keyword">end</span>
0979             <span class="keyword">end</span>
0980         <span class="keyword">end</span>
0981 
0982         <a name="_sub28" href="#_subfunctions" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a>
0983 
0984             <span class="keyword">if</span> ~strcmp(type, <span class="string">'all'</span>) &amp;&amp; ~strcmp(type, <span class="string">'nonClamped'</span>)
0985                 throw(MException(<span class="string">'TFModel:WrongInitType'</span>, <span class="keyword">...</span>
0986                                  [<span class="string">'Supported init type values: all, '</span> <span class="keyword">...</span>
0987                                   <span class="string">'nonClamped'</span>]));
0988             <span class="keyword">end</span>
0989 
0990             <span class="keyword">for</span> fi=1:length(obj.latent_factor_indices)
0991 
0992                 <span class="keyword">if</span> strcmp(type, <span class="string">'all'</span>) || <span class="keyword">...</span>
0993                         ( strcmp(type, <span class="string">'nonClamped'</span>) &amp;&amp; <span class="keyword">...</span>
0994                           obj.factors(fi).isInput == 0 )
0995                     
0996                     <span class="keyword">if</span> nargin==2
0997                         obj.factors(fi).rand_init(obj.dims);
0998                     <span class="keyword">else</span>
0999                         obj.factors(fi).rand_init(obj.dims, imax);
1000                     <span class="keyword">end</span>
1001 
1002                 <span class="keyword">end</span>
1003             <span class="keyword">end</span>
1004 
1005         <span class="keyword">end</span>
1006 
1007     <span class="keyword">end</span>
1008 
1009 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 14-Aug-2012 17:57:05 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>