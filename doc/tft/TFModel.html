<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of TFModel</title>
  <meta name="keywords" content="TFModel">
  <meta name="description" content="Represents data required to describe a tensor factorization model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html tft -->
<h1>TFModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Represents data required to describe a tensor factorization model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Represents data required to describe a tensor factorization model

   A model is represented with its name and factors array of
   TFFactor objects. dims array of TFDimension objects define
   dimensions used by this model. Dimensions are transfered to C++
   in the order defined in dims array. See examples below for a
   full model description.

   Examples:
   
   dim_i = TFDimension('name', 'i', 'cardinality', 5);
   dim_j = TFDimension('cardinality', 6, 'name', 'j');
   dim_k = TFDimension('cardinality', 7, 'name', 'k');
   dim_r = TFDimension('cardinality', 10, 'name', 'r');
   
   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);
   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);
   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);
   
   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);
   
   parafac_model.rand_init_latent_factors('all');

   See also <a href="TFDimension.html" class="code" title="">TFDimension</a>, <a href="TFFactor.html" class="code" title="">TFFactor</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFDimension.html" class="code" title="">TFDimension</a>	Represents a single dimension</li><li><a href="TFFactor.html" class="code" title="">TFFactor</a>	Represents a PLTF factor</li><li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = TFModel(varargin)</a></li><li><a href="#_sub2" class="code">function [] = pltf(obj, iternum, contract_type)</a></li><li><a href="#_sub3" class="code">function [] = delta(obj, alpha, output_name, contract_type,</a></li><li><a href="#_sub4" class="code">function [r] = eq(a,b)</a></li><li><a href="#_sub5" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a></li><li><a href="#_sub6" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj)</a></li><li><a href="#_sub7" class="code">function [graph] = schedule_dp(obj)</a></li><li><a href="#_sub8" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a></li><li><a href="#_sub9" class="code">function [newmodel] = contract(obj, dim)</a></li><li><a href="#_sub10" class="code">function [obj] = update_cost_from_latent(obj)</a></li><li><a href="#_sub11" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a></li><li><a href="#_sub12" class="code">function [size] = get_element_size(obj)</a></li><li><a href="#_sub13" class="code">function [card] = get_index_card(obj, index_char)</a></li><li><a href="#_sub14" class="code">function [factor] = get_first_non_observed_factor(obj)</a></li><li><a href="#_sub15" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a></li><li><a href="#_sub16" class="code">function [ind] = find_cell_char(obj, chars)</a></li><li><a href="#_sub17" class="code">function [r] = get_dimension_index(obj, dim)</a></li><li><a href="#_sub18" class="code">function [ordered_index_chars] = order_dims(obj,</a></li><li><a href="#_sub19" class="code">function [newmodel] = contract_all(obj, contract_type)</a></li><li><a href="#_sub20" class="code">function [contract_dims] = get_contraction_dims(obj)</a></li><li><a href="#_sub21" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a></li><li><a href="#_sub22" class="code">function [factor_inds] = latent_factor_indices(obj)</a></li><li><a href="#_sub23" class="code">function [factors] = latent_factors(obj)</a></li><li><a href="#_sub24" class="code">function [factor_ind] = observed_factor_index(obj)</a></li><li><a href="#_sub25" class="code">function [factor] = observed_factor(obj)</a></li><li><a href="#_sub26" class="code">function [factors] = observed_factors(obj)</a></li><li><a href="#_sub27" class="code">function [factors] = input_factors(obj)</a></li><li><a href="#_sub28" class="code">function [factors] = temp_factors(obj)</a></li><li><a href="#_sub29" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Represents data required to describe a tensor factorization model</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%   A model is represented with its name and factors array of</span>
0004 <span class="comment">%   TFFactor objects. dims array of TFDimension objects define</span>
0005 <span class="comment">%   dimensions used by this model. Dimensions are transfered to C++</span>
0006 <span class="comment">%   in the order defined in dims array. See examples below for a</span>
0007 <span class="comment">%   full model description.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   Examples:</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   dim_i = TFDimension('name', 'i', 'cardinality', 5);</span>
0012 <span class="comment">%   dim_j = TFDimension('cardinality', 6, 'name', 'j');</span>
0013 <span class="comment">%   dim_k = TFDimension('cardinality', 7, 'name', 'k');</span>
0014 <span class="comment">%   dim_r = TFDimension('cardinality', 10, 'name', 'r');</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);</span>
0017 <span class="comment">%   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);</span>
0018 <span class="comment">%   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%   parafac_model.rand_init_latent_factors('all');</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   See also TFDimension, TFFactor</span>
0025 
0026 classdef <a href="TFModel.html" class="code" title="">TFModel</a>
0027 
0028     properties
0029         name=<span class="string">''</span>;          <span class="comment">% name of the model</span>
0030         factors=<a href="TFFactor.html" class="code" title="">TFFactor</a>; <span class="comment">% array of TFFactor</span>
0031 
0032         dims=<a href="TFDimension.html" class="code" title="">TFDimension</a>; <span class="comment">% array of TFDimension used by factors defines</span>
0033                           <span class="comment">% order of dimensions on memory</span>
0034 
0035         cost=0;
0036 
0037     <span class="keyword">end</span>
0038 
0039     methods
0040 
0041         <a name="_sub0" href="#_subfunctions" class="code">function obj = TFModel(varargin)</a>
0042             p = inputParser;
0043             addParamValue(p, <span class="string">'name'</span>, <span class="string">''</span>, @isstr);
0044             addParamValue(p, <span class="string">'factors'</span>, [], @isvector);
0045             addParamValue(p, <span class="string">'dims'</span>, [], @isvector);
0046 
0047             parse(p,varargin{:});
0048 
0049             <span class="comment">% check if all dims elements are TFDimension objects</span>
0050             <span class="keyword">for</span> i = 1:length(p.Results.dims)
0051                 <span class="keyword">if</span> ~isa(p.Results.dims(i), <span class="string">'TFDimension'</span>)
0052                     err = MException( <span class="keyword">...</span>
0053                         [<span class="string">'TFModel:DimensionNotTFDimension'</span>], <span class="keyword">...</span>
0054                         [<span class="string">'Dimensions of TFModel must be '</span> <span class="keyword">...</span>
0055                          <span class="string">'TFDimension objects'</span>]);
0056                     throw(err);
0057                 <span class="keyword">end</span>
0058             <span class="keyword">end</span>
0059             obj.dims = p.Results.dims;
0060 
0061             <span class="comment">% check if all factors are TFFactor objects</span>
0062             <span class="keyword">for</span> i = 1:length(p.Results.factors)
0063                 <span class="keyword">if</span> ~isa(p.Results.factors(i), <span class="string">'TFFactor'</span>)
0064                     err = MException( <span class="keyword">...</span>
0065                         [<span class="string">'TFModel:FactorsNotTFFactor'</span>], <span class="keyword">...</span>
0066                         [<span class="string">'Factors of TFModel must be '</span> <span class="keyword">...</span>
0067                          <span class="string">'TFFactor objects'</span>]);
0068                     throw(err);
0069                 <span class="keyword">end</span>
0070             <span class="keyword">end</span>
0071             obj.factors = p.Results.factors;
0072 
0073             obj.name = p.Results.name;
0074 
0075         <span class="keyword">end</span>
0076 
0077         <a name="_sub1" href="#_subfunctions" class="code">function [] = pltf(obj, iternum, contract_type)</a>
0078         <span class="comment">% performs PLTF update operations on the model</span>
0079         <span class="comment">% returns estimated TFFactor (\hat(X))</span>
0080         <span class="comment">% iternum: number of iterations</span>
0081         <span class="comment">% contract_type: if optimal contractions are performed in</span>
0082         <span class="comment">% least memory using sequence</span>
0083         <span class="comment">% defines order of contraction operations</span>
0084 
0085             <span class="keyword">if</span> nargin == 2
0086                 contract_type = <span class="string">''</span>;
0087             <span class="keyword">end</span>
0088 
0089             <span class="comment">% init optimal model cache</span>
0090             <span class="keyword">global</span> ocs_cache;
0091             ocs_cache = [];
0092 
0093             hat_X = obj.observed_factor;
0094             hat_X.name = <span class="string">'hat_X'</span>;
0095 
0096             eval( [ <span class="string">'global '</span> obj.observed_factor.get_data_name() <span class="keyword">...</span>
0097                     <span class="string">';'</span> ] );
0098             <span class="keyword">global</span> hat_X_data;
0099             hat_X.rand_init(obj.dims, 100);
0100 
0101             mask = obj.observed_factor;
0102             mask.name = <span class="string">'mask'</span>;
0103             <span class="keyword">global</span> mask_data;
0104             mask_data = ones(size(hat_X_data));
0105 
0106             KL=zeros(1,iternum);
0107             <span class="keyword">for</span> iter = 1:iternum
0108                 iter
0109                 <span class="keyword">for</span> alpha=1:length(obj.latent_factor_indices)
0110                     <span class="comment">% access global data</span>
0111                     X_name = <span class="keyword">...</span>
0112                         obj.factors(obj.observed_factor_index) <span class="keyword">...</span>
0113                         .get_data_name();
0114                     eval([<span class="string">'global '</span> X_name <span class="string">';'</span>]);
0115                     Z_alpha_name = <span class="keyword">...</span>
0116                         obj.factors(alpha).get_data_name();
0117                     eval( [ <span class="string">'global '</span> Z_alpha_name <span class="string">';'</span> ] );
0118 
0119 
0120 
0121 
0122                     <span class="comment">% recalculate hat_X</span>
0123                     newmodel = obj;
0124 
0125                     <span class="keyword">if</span> iter==1 &amp;&amp; alpha==1
0126                         <span class="comment">%g = newmodel.schedule_dp();</span>
0127                         <span class="comment">%system([ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0128                         <span class="comment">%                    ' dot -o /tmp/img.eps; ' ...</span>
0129                         <span class="comment">%                    ' display  /tmp/img.eps ' ...</span>
0130                         <span class="comment">%                    ' ' ] ] );</span>
0131                     <span class="keyword">end</span>
0132 
0133                     <span class="comment">% perform contraction</span>
0134                     newmodel = newmodel.contract_all(contract_type);
0135 
0136                     <span class="comment">% store result in hat_X_data</span>
0137                     result_name = <span class="keyword">...</span>
0138                         newmodel.get_first_non_observed_factor() <span class="keyword">...</span>
0139                         .get_data_name();
0140                     eval([<span class="string">'global '</span> result_name <span class="string">';'</span>] );
0141                     eval([<span class="string">'hat_X_data = '</span> result_name <span class="string">';'</span> ] ); 
0142 
0143 
0144 
0145                     <span class="comment">% store X / hat_X in hat_X data</span>
0146                     eval( [ <span class="string">'hat_X_data  =  '</span> <span class="keyword">...</span>
0147                             X_name <span class="keyword">...</span>
0148                             <span class="string">' ./ '</span> <span class="keyword">...</span>
0149                             <span class="string">' hat_X_data ;'</span> ] );
0150 
0151 
0152                     <span class="comment">% generate D1</span>
0153                     obj.delta(alpha, <span class="string">'D1_data'</span>, contract_type, hat_X);
0154 
0155                     <span class="comment">% generate D2</span>
0156                     obj.delta(alpha, <span class="string">'D2_data'</span>, contract_type, mask);
0157 
0158                     <span class="comment">% update Z_alpha</span>
0159                     <span class="keyword">global</span> D1_data D2_data;
0160                     eval( [ Z_alpha_name <span class="string">'='</span> Z_alpha_name <span class="string">' .* '</span> <span class="keyword">...</span>
0161                             <span class="string">'D1_data'</span>                     <span class="string">' ./ '</span> <span class="keyword">...</span>
0162                             <span class="string">'D2_data ;'</span> ] );
0163 
0164 
0165                     <span class="comment">% calculate KL divergence</span>
0166                     eval ( [ <span class="string">'KL(iter) = sum(sum(sum( (hat_X_data .* '</span> X_name <span class="string">') .* '</span> <span class="keyword">...</span>
0167                              <span class="string">' (log( (hat_X_data .* '</span> X_name <span class="string">') ) - '</span> <span class="keyword">...</span>
0168                              <span class="string">'log('</span> X_name <span class="keyword">...</span>
0169                              <span class="string">') ) - (hat_X_data .* '</span> X_name <span class="string">')'</span> <span class="keyword">...</span>
0170                              <span class="string">'+ '</span> X_name <span class="keyword">...</span>
0171                              <span class="string">')));'</span> ]);
0172 
0173                 <span class="keyword">end</span>
0174             <span class="keyword">end</span>
0175             display([<span class="string">'KL divergence over iterations: '</span>]);
0176             display(KL);
0177             plot(KL);
0178             title(<span class="string">'KL divergence over iterations'</span>);
0179             xlabel(<span class="string">'iteration number'</span>);
0180             ylabel(<span class="string">'KL divergence'</span>);
0181         <span class="keyword">end</span>
0182 
0183         <a name="_sub2" href="#_subfunctions" class="code">function [] = delta(obj, alpha, output_name, contract_type, </a><span class="keyword">...</span>
0184                             A)
0185         <span class="comment">% PLTF delta function implementation</span>
0186         <span class="comment">% alpha: index of latent factor in TFModel.factors array</span>
0187         <span class="comment">% which will be updated</span>
0188         <span class="comment">% name: unique name used as the name of calculated delta</span>
0189         <span class="comment">% factor data</span>
0190         <span class="comment">% contract_type: if optimal contractions are performed in</span>
0191         <span class="comment">% least memory using sequence</span>
0192         <span class="comment">% A: operand element of delta function assumed all ones if</span>
0193         <span class="comment">% not given</span>
0194 
0195             
0196             <span class="comment">% create new model for delta operation</span>
0197             d_model = obj;
0198 
0199             <span class="comment">% remove observed factor</span>
0200             d_model.factors(d_model.observed_factor_index) = [];
0201 
0202             <span class="comment">% add Z_alpha as new observed factor</span>
0203             d_model.factors(alpha).isLatent = 0;
0204             d_model.factors(alpha).isObserved= 1;
0205 
0206             <span class="comment">% if given, add A as a new latent factor</span>
0207             <span class="keyword">if</span> nargin == 5
0208                 A.isLatent = 1;
0209                 A.isObserved = 0;
0210                 d_model.factors = [d_model.factors A];
0211             <span class="keyword">end</span>
0212 
0213 
0214             <span class="comment">%g = d_model.schedule_dp();</span>
0215             <span class="comment">%system( [ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0216             <span class="comment">%                    ' dot -o /tmp/img.eps ;  display  /tmp/img.eps; ' ] ] );</span>
0217             <span class="comment">% perform contraction</span>
0218             d_model=d_model.contract_all(contract_type);
0219 
0220             eval( [ <span class="string">'global '</span> output_name <span class="string">';'</span>] );
0221             eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0222                     d_model.get_first_non_observed_factor().get_data_name() <span class="string">';'</span><span class="keyword">...</span>
0223                   ] );
0224 
0225             eval( [ output_name <span class="string">'='</span> <span class="keyword">...</span>
0226                     d_model.get_first_non_observed_factor().get_data_name() <span class="keyword">...</span>
0227                     <span class="string">';'</span> ]);
0228         <span class="keyword">end</span>
0229 
0230         <a name="_sub3" href="#_subfunctions" class="code">function [r] = eq(a,b)</a>
0231             r = false;
0232 
0233             <span class="comment">% mark matched b factors</span>
0234             <span class="comment">% if there are any unmarked -&gt; inequal</span>
0235             <span class="comment">% problematic case:</span>
0236             <span class="comment">% a.factors ( ip, jpi ) , b.factors (  ip, pi )</span>
0237             <span class="comment">% b==a matches all b objects with a.factors(1)</span>
0238             <span class="comment">% but a~=b !</span>
0239 
0240             b_marks = zeros(size(b.factors));
0241 
0242             <span class="keyword">if</span> length(a.factors) == length(b.factors)
0243                 <span class="keyword">for</span> f_a = 1:length(a.factors)
0244                     found = 0;
0245                     <span class="keyword">for</span> f_b = 1:length(b.factors)
0246                         <span class="keyword">if</span> a.factors(f_a) == b.factors(f_b) &amp;&amp; <span class="keyword">...</span>
0247                                 b_marks(f_b) == 0
0248                             found = 1;
0249                             b_marks(f_b) = 1;
0250                             <span class="keyword">break</span>
0251                         <span class="keyword">end</span>
0252                     <span class="keyword">end</span>
0253 
0254                     <span class="keyword">if</span> found == 0
0255                         <span class="keyword">return</span>
0256                     <span class="keyword">end</span>
0257                 <span class="keyword">end</span>
0258 
0259                 r = true;
0260             <span class="keyword">end</span>
0261         <span class="keyword">end</span>
0262 
0263         <a name="_sub4" href="#_subfunctions" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a>
0264         <span class="comment">% returns list of TFDimension objects representing</span>
0265         <span class="comment">% dimensions which are required to be added to the current</span>
0266         <span class="comment">% TFModel object in order to reach initial model where</span>
0267         <span class="comment">% uncontraction_dims = {}</span>
0268         <span class="comment">% Calculation is performed as follows:</span>
0269         <span class="comment">% uncontraction_dims = contraction_dims - current_contraction_dims</span>
0270 
0271             contraction_dims = obj.get_contraction_dims();
0272             current_contraction_dims = <span class="keyword">...</span>
0273                 obj.get_current_contraction_dims();
0274             uncontraction_dims = [];
0275 
0276             <span class="keyword">for</span> cdi = 1:length(contraction_dims)
0277                 found=0;
0278                 <span class="keyword">for</span> ccdi = 1:length(current_contraction_dims)
0279                     <span class="keyword">if</span> contraction_dims(cdi) == <span class="keyword">...</span>
0280                             char(current_contraction_dims(ccdi))
0281                         found=1;
0282                         <span class="keyword">break</span>;
0283                     <span class="keyword">end</span>
0284                 <span class="keyword">end</span>
0285                 <span class="keyword">if</span> ~found
0286                     uncontraction_dims = [ uncontraction_dims <span class="keyword">...</span>
0287                                         contraction_dims(cdi) ];
0288                 <span class="keyword">end</span>
0289             <span class="keyword">end</span>
0290         <span class="keyword">end</span>
0291 
0292         <a name="_sub5" href="#_subfunctions" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj)</a>
0293         <span class="comment">% Runs schedule_dp function to generate graph with least</span>
0294         <span class="comment">% memory using contraction sequence information in it. Then</span>
0295         <span class="comment">% searches TFGraph.optimal_edges for the optimal path and</span>
0296         <span class="comment">% returns a cell list of contraction dimension names.</span>
0297 
0298             <span class="keyword">global</span> ocs_cache;
0299 
0300             found = false;
0301             <span class="keyword">for</span> o = 1:length(ocs_cache)
0302                 <span class="keyword">if</span> ocs_cache(o).model == obj
0303                     found=true;
0304                     <span class="keyword">break</span>
0305                 <span class="keyword">end</span>
0306             <span class="keyword">end</span>
0307 
0308             <span class="keyword">if</span> found
0309                 <span class="comment">%display('cache hit')</span>
0310 
0311                 <span class="comment">%display([ 'ocs dims' ])</span>
0312                 ocs_dims = ocs_cache(o).ocs_dims;
0313                 <span class="comment">%for a =1:length(ocs_dims)</span>
0314                 <span class="comment">%    ocs_dims{a}</span>
0315                 <span class="comment">%end</span>
0316                 <span class="keyword">return</span>
0317             <span class="comment">%else</span>
0318             <span class="comment">%    display('cache miss')</span>
0319             <span class="keyword">end</span>
0320 
0321 
0322             graph = obj.schedule_dp();
0323             t = graph.optimal_edges;
0324             t(t==0) = Inf;
0325             ocs_models = [];
0326             i = length(t);
0327             <span class="keyword">while</span> i ~= 1
0328                 ocs_models = [ ocs_models graph.node_list(i) ];
0329                 i = find( t(:,i) == min(t(:, i)) );
0330             <span class="keyword">end</span>
0331             ocs_models = [ ocs_models graph.node_list(i) ];
0332 
0333             ocs_dims = [];
0334             <span class="keyword">for</span> i = 1:(length(ocs_models)-1)
0335                 ocs_dims = [ ocs_dims <span class="keyword">...</span>
0336                              { setdiff( <span class="keyword">...</span>
0337                                  ocs_models(i)<span class="keyword">...</span>
0338                                  .get_current_contraction_dims, <span class="keyword">...</span>
0339                                  ocs_models(i+ <span class="keyword">...</span>
0340                                             1)<span class="keyword">...</span>
0341                                  .get_current_contraction_dims) }; <span class="keyword">...</span>
0342                            ];
0343             <span class="keyword">end</span>
0344 
0345             <span class="comment">%display([ 'cache store' ])</span>
0346             <span class="comment">%for a =1:length(ocs_dims)</span>
0347             <span class="comment">%    ocs_dims{a}</span>
0348             <span class="comment">%end</span>
0349             ocs_cache = [ ocs_cache <a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>(obj, ocs_dims) ];
0350         <span class="keyword">end</span>
0351             
0352 
0353         <a name="_sub6" href="#_subfunctions" class="code">function [graph] = schedule_dp(obj)</a>
0354         <span class="comment">% returns a tree of TFModel generated as a result of the</span>
0355         <span class="comment">% search for least memory consuming contraction sequence</span>
0356         <span class="comment">% with a dynamic programming approach</span>
0357 
0358             output_dims = obj.get_contraction_dims();
0359             contraction_dims = obj.get_contraction_dims();
0360             
0361             <span class="comment">% generate final state of contraction operation to be</span>
0362             <span class="comment">% used as the initial state of dp search</span>
0363             end_node = obj.contract_all(); <span class="comment">% must not be optimal,</span>
0364                                            <span class="comment">% infinite loop!</span>
0365 
0366             graph = <a href="TFGraph.html" class="code" title="">TFGraph</a>;
0367             process_nodes = [end_node];
0368             processing_node = 1;
0369 
0370             <span class="keyword">while</span> length(process_nodes) &gt;= processing_node
0371                 cur_node = process_nodes(processing_node);
0372                 cur_node = cur_node.update_cost_from_latent();
0373 
0374                 <span class="comment">% init graph.node_list</span>
0375                 <span class="keyword">if</span> length(graph.node_list) == 0
0376                     graph.node_list = [cur_node];
0377                     graph=graph.clear_edges();
0378                 <span class="keyword">end</span>
0379 
0380                 uncontraction_dims = cur_node.get_uncontraction_dims();
0381                 <span class="keyword">for</span> udi = 1:length(uncontraction_dims)
0382                     new_node = cur_node.uncontract(obj, <span class="keyword">...</span>
0383                                                    uncontraction_dims(udi));
0384                     new_node = new_node.update_cost_from_latent();
0385 
0386                     <span class="comment">% memoization</span>
0387                     nnidx = graph.exists(new_node);
0388                     <span class="keyword">if</span> nnidx
0389                         graph = graph.update_node(cur_node, new_node, nnidx);
0390                     <span class="keyword">else</span>
0391                         graph = graph.append_node(cur_node, new_node);
0392                         process_nodes = [ process_nodes new_node ];
0393                     <span class="keyword">end</span>
0394                 <span class="keyword">end</span>
0395 
0396                 processing_node = processing_node + 1;
0397 
0398             <span class="keyword">end</span>
0399 
0400         <span class="keyword">end</span>
0401 
0402 
0403         <a name="_sub7" href="#_subfunctions" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a>
0404         <span class="comment">% returns a new TFModel generated by adding given</span>
0405         <span class="comment">% TFDimension object dim to the model.</span>
0406         <span class="comment">% dim: TFDimension object to uncontract</span>
0407         <span class="comment">% orig_model: provides original non-contracted model data</span>
0408 
0409             newmodel = obj;
0410 
0411             newmodel.name = [ newmodel.name  <span class="keyword">...</span>
0412                               <span class="string">'_uncontract_'</span> dim.name ];
0413 
0414             uncontract_dims = obj.get_uncontraction_dims();
0415             other_dims = []; <span class="comment">% already contracted dimensions</span>
0416             <span class="keyword">for</span> i=1:length(uncontract_dims)
0417                 <span class="keyword">if</span> uncontract_dims(i) ~= dim
0418                     other_dims = [ other_dims <span class="keyword">...</span>
0419                                    uncontract_dims(i) ];
0420                 <span class="keyword">end</span>
0421             <span class="keyword">end</span>
0422 
0423             <span class="comment">% reset newmodel's factors</span>
0424             newmodel.factors = [];
0425 
0426             <span class="comment">% stores factors which will contribute to the temporary</span>
0427             <span class="comment">% factor</span>
0428             tmp_factor_parents = [];
0429 
0430 
0431             <span class="comment">% populate newmode.factors with factors independant</span>
0432             <span class="comment">% from uncontraction operation</span>
0433             <span class="keyword">for</span> fi = 1:length(orig_model.factors)
0434                 found = 0;
0435                 <span class="keyword">for</span> fdi = 1:length(orig_model.factors(fi).dims)
0436                     <span class="keyword">for</span> odi = 1:length(other_dims)
0437                         <span class="comment">% if any factor contains any one of the</span>
0438                         <span class="comment">% other_dims can not use it as it is, must</span>
0439                         <span class="comment">% create a temporary factor for those</span>
0440                         <span class="comment">% here we identify factors we will use</span>
0441                         <span class="comment">% without modification</span>
0442 
0443                         <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0444                                 orig_model.factors(fi).dims(fdi)
0445                             found=1;
0446                             <span class="keyword">break</span>
0447                         <span class="keyword">end</span>
0448                     <span class="keyword">end</span>
0449                     <span class="keyword">if</span> found, <span class="keyword">break</span>; <span class="keyword">end</span>
0450                 <span class="keyword">end</span>
0451 
0452                 <span class="keyword">if</span> ~found
0453                     <span class="comment">% if other_dims are not found in this factor then</span>
0454                     <span class="comment">% use this factor as it is in the new node</span>
0455 
0456                     newmodel.factors = [newmodel.factors <span class="keyword">...</span>
0457                                         orig_model.factors(fi) ];
0458                 <span class="keyword">else</span>
0459                     <span class="comment">% in other case this factor will be inspected</span>
0460                     <span class="comment">% further to generate temporary factor</span>
0461                     tmp_factor_parents = [ tmp_factor_parents <span class="keyword">...</span>
0462                                         orig_model.factors(fi) ];
0463                 <span class="keyword">end</span>
0464             <span class="keyword">end</span>
0465 
0466             <span class="comment">% make sure factors are unique</span>
0467             <span class="comment">%newmodel.factors = unique(newmodel.factors);</span>
0468 
0469             <span class="comment">% inspect tmp_factor_parents and generate a temporary</span>
0470             <span class="comment">% model</span>
0471             tmpf = <a href="TFFactor.html" class="code" title="">TFFactor</a>;
0472             tmpf.isTemp = 1;
0473             tmpf.name = <span class="string">'tmp'</span>;
0474             names={};
0475             tmpf.dims = [];
0476 
0477             <span class="comment">% add all dimensions of all parent factors</span>
0478             <span class="keyword">for</span> tfpi = 1:length(tmp_factor_parents)
0479                 <span class="keyword">for</span> di = 1:length(tmp_factor_parents(tfpi).dims)
0480                     <span class="keyword">if</span> tmp_factor_parents(tfpi).isLatent
0481                         <span class="comment">% if dimension is not one of the other_dims</span>
0482                         <span class="comment">% then add it to the temporary factor</span>
0483                         found = 0;
0484                         <span class="keyword">for</span> odi = 1:length(other_dims)
0485                             <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0486                                     tmp_factor_parents(tfpi).dims(di)
0487                                 found = 1;
0488                                 <span class="keyword">break</span>;
0489                             <span class="keyword">end</span>
0490                         <span class="keyword">end</span>
0491 
0492 
0493                         <span class="keyword">if</span> ~found
0494                             <span class="comment">% if not already added</span>
0495                             found2 = 0;
0496                             <span class="keyword">for</span> tmpfdind = 1:length(tmpf.dims)
0497                                 <span class="keyword">if</span> tmpf.dims(tmpfdind) == <span class="keyword">...</span>
0498                                         tmp_factor_parents(tfpi).dims(di)
0499                                     found2 = 1;
0500                                     <span class="keyword">break</span>;
0501                                 <span class="keyword">end</span>
0502                             <span class="keyword">end</span>
0503 
0504                             <span class="keyword">if</span> ~found2
0505 
0506                                 tmpf.dims = [ tmpf.dims <span class="keyword">...</span>
0507                                               tmp_factor_parents(tfpi) <span class="keyword">...</span>
0508                                               .dims(di)];
0509                                 names = [ names <span class="keyword">...</span>
0510                                           tmp_factor_parents(tfpi) <span class="keyword">...</span>
0511                                           .dims(di).name];
0512                             <span class="keyword">end</span>
0513                         <span class="keyword">end</span>
0514                     <span class="keyword">end</span>
0515                 <span class="keyword">end</span>
0516             <span class="keyword">end</span>
0517 
0518             <span class="comment">% if no names are found then there is no temporary</span>
0519             <span class="comment">% factor added</span>
0520             <span class="keyword">if</span> length(names)
0521                 <span class="comment">% make sure tmp.factor dims are unique</span>
0522                 <span class="comment">%'Ã¶nce'</span>
0523                 <span class="comment">%tmpf.dims.name</span>
0524                 <span class="comment">%tmpf.dims = unique(tmpf.dims);</span>
0525                 <span class="comment">%'sonra'</span>
0526                 <span class="comment">%tmpf.dims.name</span>
0527                 
0528                 names=obj.order_dims(unique(names));
0529                 <span class="keyword">for</span> d = 1:length(names)
0530                     tmpf.name = [ tmpf.name <span class="string">'_'</span> char(names(d)) ];
0531                 <span class="keyword">end</span>
0532                 <span class="comment">%tmpf.name = [tmpf.name '_minus_' ? ];</span>
0533                 
0534                 newmodel.factors = [ newmodel.factors tmpf ];
0535 
0536                 newmodel = newmodel.update_cost_from_latent();
0537             <span class="keyword">end</span>
0538 
0539         <span class="keyword">end</span>
0540 
0541         <a name="_sub8" href="#_subfunctions" class="code">function [newmodel] = contract(obj, dim)</a>
0542         <span class="comment">% returns a new TFModel generated by contracting obj with</span>
0543         <span class="comment">% dim which may add new temporary factors.</span>
0544         <span class="comment">% dim: TFDimension or char array or cell with the name of</span>
0545         <span class="comment">% the dimension</span>
0546 
0547             <span class="keyword">if</span> isa(dim, <span class="string">'TFDimension'</span>)
0548                 dim = dim.name;
0549             <span class="keyword">elseif</span> isa(dim, <span class="string">'cell'</span>)
0550                 dim = char(dim{1});
0551             <span class="keyword">elseif</span> ~isa(dim, <span class="string">'char'</span>)
0552                 display([<span class="string">'ERROR: unsupported dim type '</span> class(dim) <span class="keyword">...</span>
0553                          <span class="string">'was expecting TFDimension, cell or char '</span> <span class="keyword">...</span>
0554                          <span class="string">'array'</span>]);
0555                 <span class="keyword">return</span>
0556             <span class="keyword">end</span>
0557 
0558             newmodel = obj;
0559             newmodel.name = [obj.name <span class="string">'_'</span> dim];
0560 
0561             <span class="comment">% remove dim from the new model's factors'</span>
0562             contracted_factor_inds = [];
0563             <span class="keyword">for</span> f = 1:length(newmodel.factors)
0564                 <span class="keyword">if</span> ~newmodel.factors(f).isObserved
0565                     ind = <span class="keyword">...</span>
0566                         newmodel.factors(f).got_dimension(char(dim));
0567                     
0568                     <span class="keyword">if</span> ind ~= 0
0569                         <span class="comment">% remove this dimension from this factor</span>
0570                         newmodel.factors(f).dims(ind) = [];
0571 
0572                         contracted_factor_inds = <span class="keyword">...</span>
0573                             [ contracted_factor_inds f ];
0574                     <span class="keyword">end</span>
0575                 <span class="keyword">end</span>
0576             <span class="keyword">end</span>
0577 
0578             <span class="comment">% add a temporary factor including dimensions of</span>
0579             <span class="comment">% contracted factors other than contracted dimension</span>
0580             tmp=<a href="TFFactor.html" class="code" title="">TFFactor</a>;
0581             tmp.isTemp = 1;
0582             tmp.name = <span class="string">'tmp'</span>;
0583             names={};
0584             
0585             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0586                 <span class="comment">% for each dimension of the contracted factor</span>
0587                 <span class="keyword">for</span> cfi_dim = 1:length(newmodel.factors(contracted_factor_inds(cfii)).dims)
0588                     found=0;
0589                     <span class="keyword">for</span> ti = 1:length(tmp.dims)
0590                         <span class="keyword">if</span> tmp.dims(ti) == <span class="keyword">...</span>
0591                                 newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim)
0592                             found=1;
0593                             <span class="keyword">break</span>;
0594                         <span class="keyword">end</span>
0595                     <span class="keyword">end</span>
0596                     <span class="keyword">if</span> found == 0
0597                         tmp.dims = [tmp.dims <span class="keyword">...</span>
0598                                     newmodel.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0599                                     .dims(cfi_dim)];
0600                         names=[names <span class="keyword">...</span>
0601                               newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name];
0602                         <span class="comment">%display(['added from factor index' ...</span>
0603                         <span class="comment">%         contracted_factor_inds(cfii)])</span>
0604                         <span class="comment">%display(['added from factor' newmodel.factors(contracted_factor_inds(cfii)).name])</span>
0605                         <span class="comment">%display(['addd dim' char(newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name)])</span>
0606                     <span class="keyword">end</span>
0607                 <span class="keyword">end</span>
0608             <span class="keyword">end</span>
0609             names=unique(names);
0610             <span class="keyword">for</span> d = 1:length(names)
0611                 tmp.name = [tmp.name <span class="string">'_'</span> char(names(d))];
0612             <span class="keyword">end</span>
0613             tmp.name = [tmp.name <span class="string">'_minus_'</span> dim];
0614 
0615 
0616 
0617 
0618             eval( [ <span class="string">'global '</span> tmp.get_data_name()  <span class="string">';'</span>] );
0619 
0620             <span class="keyword">if</span> length(contracted_factor_inds) == 1
0621                 <span class="comment">% no multiplication</span>
0622                 eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0623                         obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0624                         .get_data_name() <span class="string">';'</span>] );
0625                 eval( [ tmp.get_data_name() <span class="string">' = '</span> <span class="keyword">...</span>
0626                         obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0627                         .get_data_name() <span class="string">';'</span>] );
0628             <span class="keyword">else</span>
0629 
0630                 <span class="comment">% multiply first two into tmp data</span>
0631                 eval( [ <span class="string">'global'</span> <span class="keyword">...</span>
0632                         <span class="string">' '</span> obj.factors(contracted_factor_inds(1)).get_data_name() <span class="keyword">...</span>
0633                         <span class="string">' '</span> obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">';'</span>] );
0634 
0635                 eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0636                         obj.factors(contracted_factor_inds(1)).get_data_name() <span class="string">', '</span><span class="keyword">...</span>
0637                         obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">');'</span> <span class="keyword">...</span>
0638                       ] );
0639 
0640                 <span class="comment">% multiply tmp data with other factors</span>
0641                 <span class="keyword">for</span> cfii = 3:length(contracted_factor_inds)
0642                     eval( [ <span class="string">'global '</span><span class="keyword">...</span>
0643                             obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0644                             .get_data_name() <span class="string">';'</span>] );
0645                     eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0646                             tmp.get_data_name() <span class="string">','</span><span class="keyword">...</span>
0647                             obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0648                             .get_data_name() <span class="string">');'</span> ] );
0649                 <span class="keyword">end</span>
0650             <span class="keyword">end</span>
0651 
0652 
0653             <span class="comment">% sum contraction dimensions on tmp data</span>
0654             
0655             con_dim_index = obj.get_dimension_index(dim);
0656 
0657             eval( [ tmp.get_data_name() <span class="string">' = sum( '</span> <span class="keyword">...</span>
0658                     tmp.get_data_name() <span class="string">', '</span> <span class="keyword">...</span>
0659                     num2str(con_dim_index) <span class="string">');'</span>] );
0660             
0661             newmodel.factors = [newmodel.factors tmp];
0662 
0663 
0664             <span class="comment">% remove contracted factors</span>
0665             <span class="comment">% other dimensions live within the tmp factor</span>
0666             removed_num=0; <span class="comment">% removal breaks loop index</span>
0667             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0668                 newmodel.factors(contracted_factor_inds(cfii) <span class="keyword">...</span>
0669                                  - removed_num) = [];
0670                 removed_num = removed_num + 1;
0671             <span class="keyword">end</span>
0672         <span class="keyword">end</span>
0673 
0674 
0675         <a name="_sub9" href="#_subfunctions" class="code">function [obj] = update_cost_from_latent(obj)</a>
0676             obj.cost = 0;
0677             lfi=obj.latent_factor_indices();
0678             <span class="keyword">for</span> fi = 1:length(lfi)
0679                 obj.cost = obj.cost + <span class="keyword">...</span>
0680                     obj.factors(lfi(fi)).get_element_size();
0681             <span class="keyword">end</span>
0682         <span class="keyword">end</span>
0683 
0684 
0685         <a name="_sub10" href="#_subfunctions" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a>
0686         <span class="comment">% returns a string to be used by fgplot</span>
0687 
0688         <span class="comment">% add dimension nodes</span>
0689             dn = [ <span class="string">'[ '''</span> ];
0690             <span class="keyword">for</span> i =1:length(obj.dims)
0691                 <span class="keyword">if</span> i ~= 1
0692                     dn = [ dn <span class="string">''','''</span> ];
0693                 <span class="keyword">end</span>
0694                 dn = [ dn obj.dims(i).name ];
0695             <span class="keyword">end</span>
0696             dn = [ dn <span class="string">''' ] '</span> ];
0697 
0698             <span class="comment">% add factor nodes</span>
0699             fn = [ <span class="string">'[ '''</span> ];
0700             <span class="keyword">for</span> i =1:length(obj.factors)
0701                 <span class="keyword">if</span> i ~= 1
0702                     fn = [ fn <span class="string">''','''</span> ];
0703                 <span class="keyword">end</span>
0704                 fn = [ fn obj.factors(i).name ];
0705             <span class="keyword">end</span>
0706             fn = [ fn <span class="string">''' ] '</span> ];
0707 
0708             <span class="comment">% add edges</span>
0709             all_edges=[<span class="string">'[ '</span> ];
0710             <span class="keyword">for</span> d = 1:length(obj.dims)
0711                 <span class="keyword">if</span> d ~= 1
0712                     all_edges = [ all_edges <span class="string">' , '</span> ];
0713                 <span class="keyword">end</span>
0714 
0715                 edges=[<span class="string">'[ '</span> ];
0716 
0717                 <span class="comment">% include this dimension if a factor uses it</span>
0718                 <span class="keyword">for</span> f = 1:length(obj.factors)
0719                     <span class="keyword">for</span> fd = 1:length(obj.factors(f).dims)
0720                         <span class="keyword">if</span> obj.factors(f).dims(fd) == obj.dims(d)
0721                             <span class="keyword">if</span> length(edges) ~= 2
0722                                 edges = [ edges <span class="string">''','''</span> ];
0723                             <span class="keyword">else</span>
0724                                 edges = [ edges <span class="string">''''</span> ];
0725                             <span class="keyword">end</span>
0726                             edges = [ edges obj.factors(f).name ];
0727                         <span class="keyword">end</span>
0728                     <span class="keyword">end</span>
0729                 <span class="keyword">end</span>
0730 
0731                 all_edges = [ all_edges edges <span class="string">''' ]'</span> ];
0732             <span class="keyword">end</span>
0733             all_edges = [ all_edges <span class="string">' ]'</span> ];
0734         <span class="keyword">end</span>
0735 
0736         <a name="_sub11" href="#_subfunctions" class="code">function [size] = get_element_size(obj)</a>
0737         <span class="comment">% returns number of elements for this model</span>
0738             size=0;
0739             <span class="keyword">for</span> f = 1:length(obj.factors)
0740                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0741                     size = size + <span class="keyword">...</span>
0742                            obj.factors(f).get_element_size();
0743                 <span class="keyword">end</span>
0744             <span class="keyword">end</span>
0745         <span class="keyword">end</span>
0746 
0747         <a name="_sub12" href="#_subfunctions" class="code">function [card] = get_index_card(obj, index_char)</a>
0748         <span class="comment">% returns cardinality of a given name of a dimension</span>
0749             <span class="keyword">for</span> d = 1:length(obj.dims)
0750                 <span class="keyword">if</span> obj.dims(d).name == index_char
0751                     card = obj.dims(d).cardinality;
0752                     <span class="keyword">break</span>
0753                 <span class="keyword">end</span>
0754             <span class="keyword">end</span>
0755         <span class="keyword">end</span>
0756 
0757         <a name="_sub13" href="#_subfunctions" class="code">function [factor] = get_first_non_observed_factor(obj)</a>
0758         <span class="comment">% returns first non observed factor index, used to return</span>
0759         <span class="comment">% index of the output factor</span>
0760             <span class="keyword">for</span> f = 1:length(obj.factors)
0761                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0762                     factor = obj.factors(f);
0763                     <span class="keyword">return</span>
0764                 <span class="keyword">end</span>
0765             <span class="keyword">end</span>
0766         <span class="keyword">end</span>
0767 
0768         <a name="_sub14" href="#_subfunctions" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a>
0769         <span class="comment">% returns first non observed factor index, used to return</span>
0770         <span class="comment">% index of the output factor</span>
0771             <span class="keyword">for</span> f = 1:length(obj.factors)
0772                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0773                     ind = f;
0774                     <span class="keyword">return</span>
0775                 <span class="keyword">end</span>
0776             <span class="keyword">end</span>
0777         <span class="keyword">end</span>
0778 
0779         <a name="_sub15" href="#_subfunctions" class="code">function [ind] = find_cell_char(obj, chars)</a>
0780         <span class="comment">% returns index of a given char array in object's dimension array</span>
0781             <span class="keyword">for</span> ind=1:length(obj.dims)
0782                 <span class="keyword">if</span> obj.dims(ind).name == chars
0783                     <span class="keyword">return</span>
0784                 <span class="keyword">end</span>
0785             <span class="keyword">end</span>
0786             ind=0;
0787         <span class="keyword">end</span>
0788 
0789        <a name="_sub16" href="#_subfunctions" class="code">function [r] = get_dimension_index(obj, dim)</a>
0790         <span class="comment">% returns index of dimension dim in obj.dims if obj</span>
0791         <span class="comment">% contains TFDimension (or char) dim returns 0 otherwise</span>
0792 
0793             r=0;
0794             <span class="keyword">for</span> d = 1:length(obj.dims)
0795                 <span class="keyword">if</span> obj.dims(d) == dim
0796                     r=d;
0797                     <span class="keyword">break</span>;
0798                 <span class="keyword">end</span>
0799             <span class="keyword">end</span>           
0800        <span class="keyword">end</span>
0801 
0802         <a name="_sub17" href="#_subfunctions" class="code">function [ordered_index_chars] = order_dims(obj, </a><span class="keyword">...</span>
0803                                                     dims_array)
0804             <span class="comment">% order given cell of dimension names according to</span>
0805             <span class="comment">% factor.dims order</span>
0806 
0807             tmp=cell(length(dims_array), 3);
0808 
0809             tmp(:,1) = dims_array;
0810             <span class="keyword">for</span> i = 1:length(dims_array)
0811                 tmp{i,2} = obj.get_index_card(char(dims_array(i)));
0812                 tmp{i,3} = obj.find_cell_char(char(dims_array(i))); <span class="comment">% order of the index</span>
0813                                                                     <span class="comment">% in the model</span>
0814             <span class="keyword">end</span>
0815 
0816             tmp=sortrows(tmp,3); <span class="comment">% sort by the order of the model indices</span>
0817             ordered_index_chars=tmp(:,1)';
0818         <span class="keyword">end</span>
0819 
0820 
0821         <a name="_sub18" href="#_subfunctions" class="code">function [newmodel] = contract_all(obj, contract_type)</a>
0822         <span class="comment">% performs all necessary contraction operations for the</span>
0823         <span class="comment">% model. if contract_type argument is equal to 'optimal'</span>
0824         <span class="comment">% then schedule_dp() is used to find the optimal (least</span>
0825         <span class="comment">% memory using) sequence and the optimal sequence is used</span>
0826         <span class="comment">% to contract all necessary dimensions. Otherwise</span>
0827         <span class="comment">% get_contraction_dims() is used to order contraction</span>
0828         <span class="comment">% operation which does not order dimensions</span>
0829 
0830             <span class="keyword">if</span> nargin == 2 &amp;&amp; strcmp(contract_type, <span class="string">'optimal'</span>)
0831                 contract_dims = <span class="keyword">...</span>
0832                     obj.get_optimal_contraction_sequence_dims();
0833 
0834                 <span class="comment">%for i=1:length(contract_dims)</span>
0835                 <span class="comment">%    display(['optimal contracting ' ...</span>
0836                 <span class="comment">%             char(contract_dims{i})]);</span>
0837                 <span class="comment">%end</span>
0838             <span class="keyword">else</span>
0839                 contract_dims = obj.get_contraction_dims();
0840 
0841                 <span class="comment">%for i=1:length(contract_dims)</span>
0842                 <span class="comment">%    display(['contracting ' contract_dims(i).name]);</span>
0843                 <span class="comment">%end</span>
0844             <span class="keyword">end</span>
0845 
0846             newmodel = obj;
0847             <span class="keyword">for</span> i = 1:length(contract_dims)
0848                 newmodel = newmodel.contract(contract_dims(i));
0849             <span class="keyword">end</span>
0850         <span class="keyword">end</span>
0851 
0852 
0853         <a name="_sub19" href="#_subfunctions" class="code">function [contract_dims] = get_contraction_dims(obj)</a>
0854         <span class="comment">% returns cell of dimensions which must be contracted to</span>
0855         <span class="comment">% calculate output factor(s)</span>
0856 
0857             output_chars = {};
0858             <span class="keyword">for</span> f=1:length(obj.factors)
0859                 <span class="keyword">if</span> obj.factors(f).isObserved
0860 
0861                     <span class="comment">% for each dimension of this factor</span>
0862                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
0863                         output_chars = [output_chars <span class="keyword">...</span>
0864                                         obj.factors(f).dims(i).name];
0865                     <span class="keyword">end</span>
0866 
0867                 <span class="keyword">end</span>
0868             <span class="keyword">end</span>
0869 
0870             <span class="comment">% contraction dimensions: alldims - output_dims</span>
0871             contract_dims={};
0872             <span class="keyword">for</span> d_a = 1:length(obj.dims)
0873                 found=0;
0874                 <span class="keyword">for</span> d_o = 1:length(output_chars)
0875                     <span class="keyword">if</span> obj.dims(d_a) == char(output_chars(d_o))
0876                         found=1;
0877                         <span class="keyword">break</span>
0878                     <span class="keyword">end</span>
0879                 <span class="keyword">end</span>
0880 
0881                 <span class="keyword">if</span> found == 0
0882                     contract_dims = [contract_dims obj.dims(d_a)];
0883                     <span class="comment">%['add '  obj.dims(d_a).name]</span>
0884                 <span class="keyword">end</span>
0885             <span class="keyword">end</span>
0886 
0887             <span class="comment">%['return ' contract_dims.name]</span>
0888             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
0889         <span class="keyword">end</span>
0890 
0891         <a name="_sub20" href="#_subfunctions" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a>
0892         <span class="comment">% returns cell of TFDimensions which must be contracted to</span>
0893         <span class="comment">% calculate output factor(s) by using current factors to</span>
0894         <span class="comment">% calculate all dimension not model.dims. (model.dims is always</span>
0895         <span class="comment">% fixed to maximum possible dimension list.)</span>
0896 
0897             output_chars = {};
0898             <span class="keyword">for</span> f=1:length(obj.factors)
0899                 <span class="keyword">if</span> obj.factors(f).isObserved
0900 
0901                     <span class="comment">% for each dimension of this factor</span>
0902                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
0903                         output_chars = [output_chars <span class="keyword">...</span>
0904                                         obj.factors(f).dims(i).name];
0905                     <span class="keyword">end</span>
0906 
0907                 <span class="keyword">end</span>
0908             <span class="keyword">end</span>
0909 
0910             <span class="comment">% contraction dimensions: alldims - output_dims</span>
0911             alldims={};
0912             <span class="keyword">for</span> f = 1:length(obj.factors)
0913                 <span class="keyword">for</span> d = 1:length(obj.factors(f).dims)
0914                     found = 0;
0915                     n=obj.factors(f).dims(d).name;
0916                     <span class="keyword">for</span> i=1:length(alldims)
0917                         <span class="keyword">if</span> char(alldims(i)) == n
0918                             found = 1;
0919                             <span class="keyword">break</span>
0920                         <span class="keyword">end</span>
0921                     <span class="keyword">end</span>
0922 
0923                     <span class="keyword">if</span> ~found
0924                         alldims = [alldims n];
0925                     <span class="keyword">end</span>
0926                 <span class="keyword">end</span>
0927             <span class="keyword">end</span>
0928 
0929             contract_dims={};
0930             <span class="keyword">for</span> d_a = 1:length(alldims)
0931                 found=0;
0932                 <span class="keyword">for</span> d_o = 1:length(output_chars)
0933                     <span class="keyword">if</span> char(alldims(d_a)) == char(output_chars(d_o))
0934                         found=1;
0935                         <span class="keyword">break</span>
0936                     <span class="keyword">end</span>
0937                 <span class="keyword">end</span>
0938 
0939                 <span class="keyword">if</span> found == 0
0940                     contract_dims = [contract_dims alldims(d_a)];
0941                     <span class="comment">%['add '  alldims(d_a).name]</span>
0942                 <span class="keyword">end</span>
0943             <span class="keyword">end</span>
0944 
0945             <span class="comment">%['return ' contract_dims.name]</span>
0946             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
0947         <span class="keyword">end</span>
0948 
0949 
0950         <a name="_sub21" href="#_subfunctions" class="code">function [factor_inds] = latent_factor_indices(obj)</a>
0951             factor_inds=[];
0952             <span class="keyword">for</span> f=1:length(obj.factors)
0953                 <span class="keyword">if</span> obj.factors(f).isLatent
0954                     factor_inds = [ factor_inds f ];
0955                 <span class="keyword">end</span>
0956             <span class="keyword">end</span>
0957         <span class="keyword">end</span>
0958 
0959 
0960         <a name="_sub22" href="#_subfunctions" class="code">function [factors] = latent_factors(obj)</a>
0961             factors=[];
0962             <span class="keyword">for</span> f=1:length(obj.factors)
0963                 <span class="keyword">if</span> obj.factors(f).isLatent
0964                     factors = [ factors obj.factors(f) ];
0965                 <span class="keyword">end</span>
0966             <span class="keyword">end</span>
0967         <span class="keyword">end</span>
0968 
0969         <a name="_sub23" href="#_subfunctions" class="code">function [factor_ind] = observed_factor_index(obj)</a>
0970             factor_ind=0;
0971             <span class="keyword">for</span> f=1:length(obj.factors)
0972                 <span class="keyword">if</span> obj.factors(f).isObserved
0973                     factor_ind = f;
0974                     <span class="keyword">return</span>
0975                 <span class="keyword">end</span>
0976             <span class="keyword">end</span>
0977         <span class="keyword">end</span>
0978 
0979         <a name="_sub24" href="#_subfunctions" class="code">function [factor] = observed_factor(obj)</a>
0980         <span class="comment">% returns first observed factor (useful for PLTF operations)</span>
0981             <span class="keyword">for</span> f=1:length(obj.factors)
0982                 <span class="keyword">if</span> obj.factors(f).isObserved
0983                     factor = obj.factors(f);
0984                     <span class="keyword">return</span>
0985                 <span class="keyword">end</span>
0986             <span class="keyword">end</span>
0987         <span class="keyword">end</span>
0988 
0989         <a name="_sub25" href="#_subfunctions" class="code">function [factors] = observed_factors(obj)</a>
0990             factors=[];
0991             <span class="keyword">for</span> f=1:length(obj.factors)
0992                 <span class="keyword">if</span> obj.factors(f).isObserved
0993                     factors = [ factors obj.factors(f) ];
0994                 <span class="keyword">end</span>
0995             <span class="keyword">end</span>
0996         <span class="keyword">end</span>
0997 
0998         <a name="_sub26" href="#_subfunctions" class="code">function [factors] = input_factors(obj)</a>
0999             factors=[];
1000             <span class="keyword">for</span> f=1:length(obj.factors)
1001                 <span class="keyword">if</span> obj.factors(f).isInput
1002                     factors = [ factors obj.factors(f) ];
1003                 <span class="keyword">end</span>
1004             <span class="keyword">end</span>
1005         <span class="keyword">end</span>
1006 
1007         <a name="_sub27" href="#_subfunctions" class="code">function [factors] = temp_factors(obj)</a>
1008             factors=[];
1009             <span class="keyword">for</span> f=1:length(obj.factors)
1010                 <span class="keyword">if</span> obj.factors(f).isTemp
1011                     factors = [ factors obj.factors(f) ];
1012                 <span class="keyword">end</span>
1013             <span class="keyword">end</span>
1014         <span class="keyword">end</span>
1015 
1016         <a name="_sub28" href="#_subfunctions" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a>
1017 
1018             <span class="keyword">if</span> ~strcmp(type, <span class="string">'all'</span>) &amp;&amp; ~strcmp(type, <span class="string">'nonClamped'</span>)
1019                 throw(MException(<span class="string">'TFModel:WrongInitType'</span>, <span class="keyword">...</span>
1020                                  [<span class="string">'Supported init type values: all, '</span> <span class="keyword">...</span>
1021                                   <span class="string">'nonClamped'</span>]));
1022             <span class="keyword">end</span>
1023 
1024             <span class="keyword">for</span> fi=1:length(obj.latent_factor_indices)
1025 
1026                 <span class="keyword">if</span> strcmp(type, <span class="string">'all'</span>) || <span class="keyword">...</span>
1027                         ( strcmp(type, <span class="string">'nonClamped'</span>) &amp;&amp; <span class="keyword">...</span>
1028                           obj.factors(fi).isInput == 0 )
1029                     
1030                     <span class="keyword">if</span> nargin==2
1031                         obj.factors(fi).rand_init(obj.dims);
1032                     <span class="keyword">else</span>
1033                         obj.factors(fi).rand_init(obj.dims, imax);
1034                     <span class="keyword">end</span>
1035 
1036                 <span class="keyword">end</span>
1037             <span class="keyword">end</span>
1038 
1039         <span class="keyword">end</span>
1040 
1041     <span class="keyword">end</span>
1042 
1043 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 16-Aug-2012 11:19:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34148766-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
