<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of TFModel</title>
  <meta name="keywords" content="TFModel">
  <meta name="description" content="Represents data required to describe a tensor factorization model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html tft -->
<h1>TFModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Represents data required to describe a tensor factorization model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Represents data required to describe a tensor factorization model

   A model is represented with its name and factors array of
   TFFactor objects. dims array of TFDimension objects define
   dimensions used by this model. Dimensions are transfered to C++
   in the order defined in dims array. See examples below for a
   full model description.

   Examples:
   
   dim_i = TFDimension('name', 'i', 'cardinality', 5);
   dim_j = TFDimension('cardinality', 6, 'name', 'j');
   dim_k = TFDimension('cardinality', 7, 'name', 'k');
   dim_r = TFDimension('cardinality', 10, 'name', 'r');
   
   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);
   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);
   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);
   
   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);
   
   parafac_model.rand_init_latent_factors('all');

   See also <a href="TFDimension.html" class="code" title="">TFDimension</a>, <a href="TFFactor.html" class="code" title="">TFFactor</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFDimension.html" class="code" title="">TFDimension</a>	Represents a single dimension</li><li><a href="TFFactor.html" class="code" title="">TFFactor</a>	Represents a PLTF factor</li><li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="TFGraph.html" class="code" title="">TFGraph</a>	Represents a graph of TFModel objects.</li><li><a href="TFModel.html" class="code" title="">TFModel</a>	Represents data required to describe a tensor factorization model</li><li><a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>	Represents cached search results for optimal contraction sequence search operation</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = TFModel(varargin)</a></li><li><a href="#_sub2" class="code">function [] = pltf(obj, iternum, contract_type, operation_type)</a></li><li><a href="#_sub3" class="code">function [ kl extra_mem ] = pltf_iteration(obj,</a></li><li><a href="#_sub4" class="code">function [extra_mem] = delta(obj, alpha, output_name,</a></li><li><a href="#_sub5" class="code">function [graph] = schedule_dp(obj, operation_type)</a></li><li><a href="#_sub6" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a></li><li><a href="#_sub7" class="code">function [newmodel extra_mem] = contract_all(obj, contract_type, operation_type)</a></li><li><a href="#_sub8" class="code">function [newmodel extra_mem] = contract_full(obj, operation_type)</a></li><li><a href="#_sub9" class="code">function [newmodel extra_mem] = contract(obj, dim, operation_type)</a></li><li><a href="#_sub10" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj,</a></li><li><a href="#_sub11" class="code">function [obj] = update_cost_from_latent(obj)</a></li><li><a href="#_sub12" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a></li><li><a href="#_sub13" class="code">function [size] = get_element_size(obj)</a></li><li><a href="#_sub14" class="code">function [card] = get_index_card(obj, index_char)</a></li><li><a href="#_sub15" class="code">function [factor] = get_first_non_observed_factor(obj)</a></li><li><a href="#_sub16" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a></li><li><a href="#_sub17" class="code">function [ind] = find_cell_char(obj, chars)</a></li><li><a href="#_sub18" class="code">function [r] = get_dimension_index(obj, dim)</a></li><li><a href="#_sub19" class="code">function [ordered_index_chars] = order_dims(obj,</a></li><li><a href="#_sub20" class="code">function [contract_dims] = get_contraction_dims(obj)</a></li><li><a href="#_sub21" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a></li><li><a href="#_sub22" class="code">function [factor_inds] = latent_factor_indices(obj)</a></li><li><a href="#_sub23" class="code">function [factors] = latent_factors(obj)</a></li><li><a href="#_sub24" class="code">function [factor_ind] = observed_factor_index(obj)</a></li><li><a href="#_sub25" class="code">function [factor] = observed_factor(obj)</a></li><li><a href="#_sub26" class="code">function [factors] = observed_factors(obj)</a></li><li><a href="#_sub27" class="code">function [factors] = input_factors(obj)</a></li><li><a href="#_sub28" class="code">function [factors] = temp_factors(obj)</a></li><li><a href="#_sub29" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a></li><li><a href="#_sub30" class="code">function [r] = eq(a,b)</a></li><li><a href="#_sub31" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Represents data required to describe a tensor factorization model</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%   A model is represented with its name and factors array of</span>
0004 <span class="comment">%   TFFactor objects. dims array of TFDimension objects define</span>
0005 <span class="comment">%   dimensions used by this model. Dimensions are transfered to C++</span>
0006 <span class="comment">%   in the order defined in dims array. See examples below for a</span>
0007 <span class="comment">%   full model description.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   Examples:</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   dim_i = TFDimension('name', 'i', 'cardinality', 5);</span>
0012 <span class="comment">%   dim_j = TFDimension('cardinality', 6, 'name', 'j');</span>
0013 <span class="comment">%   dim_k = TFDimension('cardinality', 7, 'name', 'k');</span>
0014 <span class="comment">%   dim_r = TFDimension('cardinality', 10, 'name', 'r');</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%   p_A=TFFactor('name', 'p_A', 'type', 'latent', 'dims', [dim_i dim_r]);</span>
0017 <span class="comment">%   p_B=TFFactor('name', 'p_B', 'type', 'latent', 'dims', [dim_j dim_r]);</span>
0018 <span class="comment">%   p_C=TFFactor('name', 'p_C', 'type', 'latent', 'dims', [dim_k dim_r]);</span>
0019 <span class="comment">%</span>
0020 <span class="comment">%   parafac_model = TFModel('name', 'Parafac', 'factors', [p_A p_B p_C X], 'dims', [dim_i dim_j dim_k dim_r]);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%   parafac_model.rand_init_latent_factors('all');</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   See also TFDimension, TFFactor</span>
0025 
0026 classdef <a href="TFModel.html" class="code" title="">TFModel</a>
0027 
0028 
0029     properties
0030         name=<span class="string">''</span>;          <span class="comment">% name of the model</span>
0031         factors=<a href="TFFactor.html" class="code" title="">TFFactor</a>; <span class="comment">% array of TFFactor</span>
0032 
0033         dims=<a href="TFDimension.html" class="code" title="">TFDimension</a>; <span class="comment">% array of TFDimension used by factors defines</span>
0034                           <span class="comment">% order of dimensions on memory</span>
0035 
0036         cost=0;
0037 
0038     <span class="keyword">end</span>
0039 
0040 
0041     methods
0042 
0043         <a name="_sub0" href="#_subfunctions" class="code">function obj = TFModel(varargin)</a>
0044             p = inputParser;
0045             addParamValue(p, <span class="string">'name'</span>, <span class="string">''</span>, @isstr);
0046             addParamValue(p, <span class="string">'factors'</span>, [], @isvector);
0047             addParamValue(p, <span class="string">'dims'</span>, [], @isvector);
0048 
0049             parse(p,varargin{:});
0050 
0051             <span class="comment">% check if all dims elements are TFDimension objects</span>
0052             <span class="keyword">for</span> i = 1:length(p.Results.dims)
0053                 <span class="keyword">if</span> ~isa(p.Results.dims(i), <span class="string">'TFDimension'</span>)
0054                     err = MException( <span class="keyword">...</span>
0055                         [<span class="string">'TFModel:DimensionNotTFDimension'</span>], <span class="keyword">...</span>
0056                         [<span class="string">'Dimensions of TFModel must be '</span> <span class="keyword">...</span>
0057                          <span class="string">'TFDimension objects'</span>]);
0058                     throw(err);
0059                 <span class="keyword">end</span>
0060             <span class="keyword">end</span>
0061             obj.dims = p.Results.dims;
0062 
0063             <span class="comment">% check if all factors are TFFactor objects</span>
0064             <span class="keyword">for</span> i = 1:length(p.Results.factors)
0065                 <span class="keyword">if</span> ~isa(p.Results.factors(i), <span class="string">'TFFactor'</span>)
0066                     err = MException( <span class="keyword">...</span>
0067                         [<span class="string">'TFModel:FactorsNotTFFactor'</span>], <span class="keyword">...</span>
0068                         [<span class="string">'Factors of TFModel must be '</span> <span class="keyword">...</span>
0069                          <span class="string">'TFFactor objects'</span>]);
0070                     throw(err);
0071                 <span class="keyword">end</span>
0072             <span class="keyword">end</span>
0073             obj.factors = p.Results.factors;
0074 
0075             obj.name = p.Results.name;
0076 
0077         <span class="keyword">end</span>
0078 
0079 
0080 
0081 
0082         <a name="_sub1" href="#_subfunctions" class="code">function [] = pltf(obj, iternum, contract_type, operation_type)</a>
0083         <span class="comment">% performs PLTF update operations on the model</span>
0084         <span class="comment">% returns estimated TFFactor (\hat(X))</span>
0085         <span class="comment">%</span>
0086         <span class="comment">% iternum: number of iterations</span>
0087         <span class="comment">%</span>
0088         <span class="comment">% contract_type: if equals to 'optimal', contractions are</span>
0089         <span class="comment">% performed in least memory using sequence defines order of</span>
0090         <span class="comment">% contraction operations, if equals to 'full', full tensor</span>
0091         <span class="comment">% is used for contraction operations instead of generating</span>
0092         <span class="comment">% temporary factors.</span>
0093         <span class="comment">%</span>
0094         <span class="comment">% operation_type: if equals to 'compute' normal contraction</span>
0095         <span class="comment">% operations are performed. if equals to 'mem_analysis'</span>
0096         <span class="comment">% operation are not performed but memory requirement is</span>
0097         <span class="comment">% calculated and reported.</span>
0098 
0099             <span class="keyword">if</span> nargin == 2
0100                 contract_type = <span class="string">''</span>;
0101             <span class="keyword">end</span>
0102             <span class="keyword">if</span> nargin &lt; 4
0103                 operation_type = <span class="string">'compute'</span>;
0104             <span class="keyword">end</span>
0105 
0106 
0107             <span class="comment">% init optimal model cache</span>
0108             <span class="keyword">global</span> ocs_cache;
0109             ocs_cache = [];
0110 
0111             <span class="comment">% initalize data_mem with memory requirements of the</span>
0112             <span class="comment">% model elements</span>
0113             data_mem = obj.get_element_size();
0114 
0115             hat_X = obj.observed_factor;
0116             hat_X.name = <span class="string">'hat_X'</span>;
0117             <span class="comment">% hat_X requires extra memory</span>
0118             data_mem = data_mem + hat_X.get_element_size();
0119 
0120             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0121                 eval( [ <span class="string">'global '</span> obj.observed_factor.get_data_name() <span class="keyword">...</span>
0122                         <span class="string">';'</span> ] );
0123                 <span class="keyword">global</span> hat_X_data;
0124                 hat_X.rand_init(obj.dims, 100);
0125             <span class="keyword">end</span>
0126 
0127             mask = obj.observed_factor;
0128             mask.name = <span class="string">'mask'</span>;
0129             <span class="comment">% mask requires extra memory</span>
0130             data_mem = data_mem + mask.get_element_size();
0131 
0132             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0133                 <span class="keyword">global</span> mask_data;
0134                 mask_data = ones(size(hat_X_data));
0135                 KL=zeros(1,iternum);
0136                 <span class="keyword">for</span> iter = 1:iternum
0137                     display([<span class="string">'iteration'</span> char(9) num2str(iter)]);
0138                     [ kl extra_mem ] = obj.pltf_iteration(contract_type, <span class="keyword">...</span>
0139                                                           hat_X, <span class="keyword">...</span>
0140                                                           mask, <span class="keyword">...</span>
0141                                                           operation_type);
0142                     KL(iter) = kl;
0143                 <span class="keyword">end</span>
0144 
0145                 display([<span class="string">'KL divergence over iterations: '</span>]);
0146                 display(KL);
0147                 plot(KL);
0148                 title(<span class="string">'KL divergence over iterations'</span>);
0149                 xlabel(<span class="string">'iteration number'</span>);
0150                 ylabel(<span class="string">'KL divergence'</span>);
0151 
0152             <span class="keyword">elseif</span> strcmp( operation_type, <span class="string">'mem_analysis'</span> )
0153                 [ kl extra_mem ] = obj.pltf_iteration(contract_type, hat_X, <span class="keyword">...</span>
0154                                                       mask, <span class="keyword">...</span>
0155                                                       operation_type);
0156                 
0157             <span class="keyword">end</span>
0158 
0159             data_mem = data_mem + extra_mem;
0160             display([char(10) <span class="keyword">...</span>
0161                      <span class="string">'data elements required: '</span> num2str(data_mem) <span class="keyword">...</span>
0162                      char(10) <span class="keyword">...</span>
0163                      [<span class="string">'memory size with (8 byte) double precision: '</span> <span class="keyword">...</span>
0164                       num2str(8 * data_mem / 1000 / 1000) <span class="string">' MB'</span> ] ] );
0165         <span class="keyword">end</span>
0166 
0167 
0168 
0169 
0170         <a name="_sub2" href="#_subfunctions" class="code">function [ kl extra_mem ] = pltf_iteration(obj, </a><span class="keyword">...</span>
0171                                                   contract_type, <span class="keyword">...</span>
0172                                                   hat_X, mask, <span class="keyword">...</span>
0173                                                   operation_type)
0174             <span class="comment">% helper function for the pltf inner loop</span>
0175             <span class="comment">% operation_type: 'compute' if actual computation is</span>
0176             <span class="comment">% requested, 'mem_analysis' if only memory usage</span>
0177             <span class="comment">% computation is requested</span>
0178             <span class="comment">%</span>
0179             <span class="comment">% returns KL divergence value calculated at the end of</span>
0180             <span class="comment">% the operations. extra_mem is incremented with</span>
0181             <span class="comment">% temporary data usage requirements</span>
0182 
0183             extra_mem = 0;
0184             <span class="keyword">for</span> alpha=1:length(obj.latent_factor_indices)
0185                 <span class="comment">% access global data</span>
0186                 eval( [ <span class="string">'global '</span> obj.observed_factor.get_data_name() <span class="keyword">...</span>
0187                         <span class="string">';'</span> ] );
0188                 <span class="keyword">global</span> hat_X_data mask_data;
0189                 X_name = obj.factors(obj.observed_factor_index) <span class="keyword">...</span>
0190                          .get_data_name();
0191                 eval([<span class="string">'global '</span> X_name <span class="string">';'</span>]);
0192                 Z_alpha_name = <span class="keyword">...</span>
0193                     obj.factors(alpha).get_data_name();
0194                 eval( [ <span class="string">'global '</span> Z_alpha_name <span class="string">';'</span> ] );
0195 
0196                 <span class="comment">% recalculate hat_X</span>
0197                 newmodel = obj;
0198 
0199                 <span class="comment">%if iter==1 &amp;&amp; alpha==1</span>
0200                     <span class="comment">%g = newmodel.schedule_dp(operation_type);</span>
0201                     <span class="comment">%system([ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0202                     <span class="comment">%                    ' dot -o /tmp/img.eps; ' ...</span>
0203                     <span class="comment">%                    ' display  /tmp/img.eps ' ...</span>
0204                     <span class="comment">%                    ' ' ] ] );</span>
0205                 <span class="comment">%end</span>
0206 
0207                 <span class="comment">% perform contraction</span>
0208                 [ newmodel e_m ] = <span class="keyword">...</span>
0209                     newmodel.contract_all(contract_type, <span class="keyword">...</span>
0210                                           operation_type);
0211 
0212                 extra_mem = extra_mem + e_m;
0213 
0214 
0215                 <span class="comment">% store result in hat_X_data</span>
0216                 result_name = <span class="keyword">...</span>
0217                     newmodel.get_first_non_observed_factor() <span class="keyword">...</span>
0218                     .get_data_name();
0219                 eval([<span class="string">'global '</span> result_name <span class="string">';'</span>] );
0220                 eval([<span class="string">'hat_X_data = '</span> result_name <span class="string">';'</span> ] ); 
0221 
0222 
0223 
0224                 <span class="comment">% store X / hat_X in hat_X data</span>
0225                 <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0226                     eval( [ <span class="string">'hat_X_data  =  '</span> <span class="keyword">...</span>
0227                             X_name <span class="keyword">...</span>
0228                             <span class="string">' ./ '</span> <span class="keyword">...</span>
0229                             <span class="string">' hat_X_data ;'</span> ] );
0230                 <span class="keyword">end</span>
0231 
0232 
0233                 <span class="comment">% generate D1</span>
0234                 [ e_m ] = obj.delta(alpha, <span class="string">'D1_data'</span>, <span class="keyword">...</span>
0235                                     contract_type, <span class="keyword">...</span>
0236                                     operation_type, <span class="keyword">...</span>
0237                                     hat_X);
0238                 extra_mem = extra_mem + e_m;                
0239 
0240                 <span class="comment">% generate D2</span>
0241                 [ e_m ] = obj.delta(alpha, <span class="string">'D2_data'</span>, <span class="keyword">...</span>
0242                                     contract_type, <span class="keyword">...</span>
0243                                     operation_type, <span class="keyword">...</span>
0244                                     mask);
0245                 extra_mem = extra_mem + e_m;
0246 
0247                 <span class="comment">% update Z_alpha</span>
0248                 <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0249                     <span class="keyword">global</span> D1_data D2_data;
0250                     eval( [ Z_alpha_name <span class="string">'='</span> Z_alpha_name <span class="string">' .* '</span> <span class="keyword">...</span>
0251                             <span class="string">'D1_data'</span>                     <span class="string">' ./ '</span> <span class="keyword">...</span>
0252                             <span class="string">'D2_data ;'</span> ] );
0253                 <span class="keyword">end</span>
0254             <span class="keyword">end</span>
0255 
0256             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0257                 <span class="comment">% calculate KL divergence</span>
0258                 eval ( [ <span class="string">'kl = sum(sum(sum( (hat_X_data .* '</span> X_name <span class="string">') .* '</span> <span class="keyword">...</span>
0259                          <span class="string">' (log( (hat_X_data .* '</span> X_name <span class="string">') ) - '</span> <span class="keyword">...</span>
0260                          <span class="string">'log('</span> X_name <span class="keyword">...</span>
0261                          <span class="string">') ) - (hat_X_data .* '</span> X_name <span class="string">')'</span> <span class="keyword">...</span>
0262                          <span class="string">'+ '</span> X_name <span class="keyword">...</span>
0263                          <span class="string">')));'</span> ]);
0264             <span class="keyword">else</span>
0265                 kl = 0;
0266             <span class="keyword">end</span>
0267         <span class="keyword">end</span>
0268 
0269 
0270 
0271 
0272         <a name="_sub3" href="#_subfunctions" class="code">function [extra_mem] = delta(obj, alpha, output_name, </a><span class="keyword">...</span>
0273                                      contract_type, operation_type, <span class="keyword">...</span>
0274                                      A)
0275         <span class="comment">% PLTF delta function implementation</span>
0276         <span class="comment">% alpha: index of latent factor in TFModel.factors array</span>
0277         <span class="comment">% which will be updated</span>
0278         <span class="comment">% name: unique name used as the name of calculated delta</span>
0279         <span class="comment">% factor data</span>
0280         <span class="comment">% contract_type: see description in pltf function</span>
0281         <span class="comment">% A: operand element of delta function assumed all ones if</span>
0282         <span class="comment">% not given</span>
0283         <span class="comment">%</span>
0284         <span class="comment">% returns extra_mem required by temporary tensor usage</span>
0285             
0286             extra_mem = 0;
0287 
0288             <span class="comment">% create new model for delta operation</span>
0289             d_model = obj;
0290 
0291             <span class="comment">% remove observed factor</span>
0292             d_model.factors(d_model.observed_factor_index) = [];
0293 
0294             <span class="comment">% add Z_alpha as new observed factor</span>
0295             d_model.factors(alpha).isLatent = 0;
0296             d_model.factors(alpha).isObserved= 1;
0297 
0298             <span class="comment">% if given, add A as a new latent factor</span>
0299             <span class="keyword">if</span> nargin == 6
0300                 A.isLatent = 1;
0301                 A.isObserved = 0;
0302                 d_model.factors = [d_model.factors A];
0303             <span class="keyword">end</span>
0304 
0305 
0306             <span class="comment">%g = d_model.schedule_dp(operation_type);</span>
0307             <span class="comment">%system( [ 'rm /tmp/img.eps; echo '' ' g.print_dot  [' '' |' ...</span>
0308             <span class="comment">%                    ' dot -o /tmp/img.eps ;  display  /tmp/img.eps; ' ] ] );</span>
0309 
0310             <span class="comment">% perform contraction</span>
0311             [ d_model e_m ] = d_model.contract_all(contract_type, <span class="keyword">...</span>
0312                                                    operation_type);
0313             extra_mem = extra_mem + e_m;
0314 
0315             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0316 
0317                 eval( [ <span class="string">'global '</span> output_name <span class="string">';'</span>] );
0318                 eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0319                         d_model.get_first_non_observed_factor().get_data_name() <span class="string">';'</span><span class="keyword">...</span>
0320                       ] );
0321 
0322                 eval( [ output_name <span class="string">'='</span> <span class="keyword">...</span>
0323                         d_model.get_first_non_observed_factor().get_data_name() <span class="keyword">...</span>
0324                         <span class="string">';'</span> ]);
0325             <span class="keyword">end</span>
0326         <span class="keyword">end</span>
0327 
0328 
0329 
0330 
0331         <a name="_sub4" href="#_subfunctions" class="code">function [graph] = schedule_dp(obj, operation_type)</a>
0332         <span class="comment">% returns a tree of TFModel generated as a result of the</span>
0333         <span class="comment">% search for least memory consuming contraction sequence</span>
0334         <span class="comment">% with a dynamic programming approach</span>
0335 
0336             output_dims = obj.get_contraction_dims();
0337             contraction_dims = obj.get_contraction_dims();
0338             
0339             <span class="comment">% generate final state of contraction operation to be</span>
0340             <span class="comment">% used as the initial state of dp search</span>
0341             end_node = obj.contract_all(<span class="string">'standard'</span>, <span class="keyword">...</span><span class="comment">  % must not be optimal or infinite loop!</span>
0342                                         operation_type);
0343 
0344             graph = <a href="TFGraph.html" class="code" title="">TFGraph</a>;
0345             process_nodes = [end_node];
0346             processing_node = 1;
0347 
0348             <span class="keyword">while</span> length(process_nodes) &gt;= processing_node
0349                 cur_node = process_nodes(processing_node);
0350                 cur_node = cur_node.update_cost_from_latent();
0351 
0352                 <span class="comment">% init graph.node_list</span>
0353                 <span class="keyword">if</span> length(graph.node_list) == 0
0354                     graph.node_list = [cur_node];
0355                     graph=graph.clear_edges();
0356                 <span class="keyword">end</span>
0357 
0358                 uncontraction_dims = cur_node.get_uncontraction_dims();
0359                 <span class="keyword">for</span> udi = 1:length(uncontraction_dims)
0360                     new_node = cur_node.uncontract(obj, <span class="keyword">...</span>
0361                                                    uncontraction_dims(udi));
0362                     new_node = new_node.update_cost_from_latent();
0363 
0364                     <span class="comment">% memoization</span>
0365                     nnidx = graph.exists(new_node);
0366                     <span class="keyword">if</span> nnidx
0367                         graph = graph.update_node(cur_node, new_node, nnidx);
0368                     <span class="keyword">else</span>
0369                         graph = graph.append_node(cur_node, new_node);
0370                         process_nodes = [ process_nodes new_node ];
0371                     <span class="keyword">end</span>
0372                 <span class="keyword">end</span>
0373 
0374                 processing_node = processing_node + 1;
0375 
0376             <span class="keyword">end</span>
0377 
0378         <span class="keyword">end</span>
0379 
0380 
0381 
0382 
0383         <a name="_sub5" href="#_subfunctions" class="code">function [newmodel] = uncontract(obj, orig_model, dim)</a>
0384         <span class="comment">% returns a new TFModel generated by adding given</span>
0385         <span class="comment">% TFDimension object dim to the model.</span>
0386         <span class="comment">% dim: TFDimension object to uncontract</span>
0387         <span class="comment">% orig_model: provides original non-contracted model data</span>
0388 
0389             newmodel = obj;
0390 
0391             newmodel.name = [ newmodel.name  <span class="keyword">...</span>
0392                               <span class="string">'_uncontract_'</span> dim.name ];
0393 
0394             uncontract_dims = obj.get_uncontraction_dims();
0395             other_dims = []; <span class="comment">% already contracted dimensions</span>
0396             <span class="keyword">for</span> i=1:length(uncontract_dims)
0397                 <span class="keyword">if</span> uncontract_dims(i) ~= dim
0398                     other_dims = [ other_dims <span class="keyword">...</span>
0399                                    uncontract_dims(i) ];
0400                 <span class="keyword">end</span>
0401             <span class="keyword">end</span>
0402 
0403             <span class="comment">% reset newmodel's factors</span>
0404             newmodel.factors = [];
0405 
0406             <span class="comment">% stores factors which will contribute to the temporary</span>
0407             <span class="comment">% factor</span>
0408             tmp_factor_parents = [];
0409 
0410 
0411             <span class="comment">% populate newmode.factors with factors independant</span>
0412             <span class="comment">% from uncontraction operation</span>
0413             <span class="keyword">for</span> fi = 1:length(orig_model.factors)
0414                 found = 0;
0415                 <span class="keyword">for</span> fdi = 1:length(orig_model.factors(fi).dims)
0416                     <span class="keyword">for</span> odi = 1:length(other_dims)
0417                         <span class="comment">% if any factor contains any one of the</span>
0418                         <span class="comment">% other_dims can not use it as it is, must</span>
0419                         <span class="comment">% create a temporary factor for those</span>
0420                         <span class="comment">% here we identify factors we will use</span>
0421                         <span class="comment">% without modification</span>
0422 
0423                         <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0424                                 orig_model.factors(fi).dims(fdi)
0425                             found=1;
0426                             <span class="keyword">break</span>
0427                         <span class="keyword">end</span>
0428                     <span class="keyword">end</span>
0429                     <span class="keyword">if</span> found, <span class="keyword">break</span>; <span class="keyword">end</span>
0430                 <span class="keyword">end</span>
0431 
0432                 <span class="keyword">if</span> ~found
0433                     <span class="comment">% if other_dims are not found in this factor then</span>
0434                     <span class="comment">% use this factor as it is in the new node</span>
0435 
0436                     newmodel.factors = [newmodel.factors <span class="keyword">...</span>
0437                                         orig_model.factors(fi) ];
0438                 <span class="keyword">else</span>
0439                     <span class="comment">% in other case this factor will be inspected</span>
0440                     <span class="comment">% further to generate temporary factor</span>
0441                     tmp_factor_parents = [ tmp_factor_parents <span class="keyword">...</span>
0442                                         orig_model.factors(fi) ];
0443                 <span class="keyword">end</span>
0444             <span class="keyword">end</span>
0445 
0446             <span class="comment">% make sure factors are unique</span>
0447             <span class="comment">%newmodel.factors = unique(newmodel.factors);</span>
0448 
0449             <span class="comment">% inspect tmp_factor_parents and generate a temporary</span>
0450             <span class="comment">% model</span>
0451             tmpf = <a href="TFFactor.html" class="code" title="">TFFactor</a>;
0452             tmpf.isTemp = 1;
0453             tmpf.name = <span class="string">'tmp'</span>;
0454             names={};
0455             tmpf.dims = [];
0456 
0457             <span class="comment">% add all dimensions of all parent factors</span>
0458             <span class="keyword">for</span> tfpi = 1:length(tmp_factor_parents)
0459                 <span class="keyword">for</span> di = 1:length(tmp_factor_parents(tfpi).dims)
0460                     <span class="keyword">if</span> tmp_factor_parents(tfpi).isLatent
0461                         <span class="comment">% if dimension is not one of the other_dims</span>
0462                         <span class="comment">% then add it to the temporary factor</span>
0463                         found = 0;
0464                         <span class="keyword">for</span> odi = 1:length(other_dims)
0465                             <span class="keyword">if</span> other_dims(odi) == <span class="keyword">...</span>
0466                                     tmp_factor_parents(tfpi).dims(di)
0467                                 found = 1;
0468                                 <span class="keyword">break</span>;
0469                             <span class="keyword">end</span>
0470                         <span class="keyword">end</span>
0471 
0472 
0473                         <span class="keyword">if</span> ~found
0474                             <span class="comment">% if not already added</span>
0475                             found2 = 0;
0476                             <span class="keyword">for</span> tmpfdind = 1:length(tmpf.dims)
0477                                 <span class="keyword">if</span> tmpf.dims(tmpfdind) == <span class="keyword">...</span>
0478                                         tmp_factor_parents(tfpi).dims(di)
0479                                     found2 = 1;
0480                                     <span class="keyword">break</span>;
0481                                 <span class="keyword">end</span>
0482                             <span class="keyword">end</span>
0483 
0484                             <span class="keyword">if</span> ~found2
0485 
0486                                 tmpf.dims = [ tmpf.dims <span class="keyword">...</span>
0487                                               tmp_factor_parents(tfpi) <span class="keyword">...</span>
0488                                               .dims(di)];
0489                                 names = [ names <span class="keyword">...</span>
0490                                           tmp_factor_parents(tfpi) <span class="keyword">...</span>
0491                                           .dims(di).name];
0492                             <span class="keyword">end</span>
0493                         <span class="keyword">end</span>
0494                     <span class="keyword">end</span>
0495                 <span class="keyword">end</span>
0496             <span class="keyword">end</span>
0497 
0498             <span class="comment">% if no names are found then there is no temporary</span>
0499             <span class="comment">% factor added</span>
0500             <span class="keyword">if</span> length(names)
0501                 <span class="comment">% make sure tmp.factor dims are unique</span>
0502                 <span class="comment">%'önce'</span>
0503                 <span class="comment">%tmpf.dims.name</span>
0504                 <span class="comment">%tmpf.dims = unique(tmpf.dims);</span>
0505                 <span class="comment">%'sonra'</span>
0506                 <span class="comment">%tmpf.dims.name</span>
0507                 
0508                 names=obj.order_dims(unique(names));
0509                 <span class="keyword">for</span> d = 1:length(names)
0510                     tmpf.name = [ tmpf.name <span class="string">'_'</span> char(names(d)) ];
0511                 <span class="keyword">end</span>
0512                 <span class="comment">%tmpf.name = [tmpf.name '_minus_' ? ];</span>
0513                 
0514                 newmodel.factors = [ newmodel.factors tmpf ];
0515 
0516                 newmodel = newmodel.update_cost_from_latent();
0517             <span class="keyword">end</span>
0518 
0519         <span class="keyword">end</span>
0520 
0521 
0522 
0523 
0524         <a name="_sub6" href="#_subfunctions" class="code">function [newmodel extra_mem] = contract_all(obj, contract_type, operation_type)</a>
0525         <span class="comment">% Performs all necessary contraction operations for the</span>
0526         <span class="comment">% model. If contract_type argument is equal to 'optimal'</span>
0527         <span class="comment">% then schedule_dp() is used to find the optimal (least</span>
0528         <span class="comment">% memory using) sequence and the optimal sequence is used</span>
0529         <span class="comment">% to contract all necessary dimensions. Otherwise</span>
0530         <span class="comment">% get_contraction_dims() is used to order contraction</span>
0531         <span class="comment">% operation which does not order dimensions. If</span>
0532         <span class="comment">% contract_type equals to 'full', no intermediate</span>
0533         <span class="comment">% contractions are performed, full tensor is calculated and</span>
0534         <span class="comment">% then contracted into the output tensor</span>
0535         <span class="comment">%</span>
0536         <span class="comment">% operation_type argument may be 'compute' or</span>
0537         <span class="comment">% 'mem_analysis'. Normal operations are performed in</span>
0538         <span class="comment">% 'compute' (default), memory usage is reported in</span>
0539         <span class="comment">% 'mem_analysis' case.</span>
0540         <span class="comment">%</span>
0541         <span class="comment">% returns the model generated after contracting all</span>
0542         <span class="comment">% necessary dimension and the total extra memory required</span>
0543         <span class="comment">% by all temporary elements</span>
0544 
0545             <span class="keyword">if</span> nargin &lt; 3
0546                 operation_type = <span class="string">'compute'</span>;
0547             <span class="keyword">end</span>
0548 
0549             <span class="keyword">if</span> nargin &lt; 2
0550                 contract_type = <span class="string">'standard'</span>;
0551             <span class="keyword">end</span>
0552 
0553             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'optimal'</span> )
0554                 contract_dims = <span class="keyword">...</span>
0555                     obj.get_optimal_contraction_sequence_dims(operation_type);
0556 
0557                 <span class="comment">%for i=1:length(contract_dims)</span>
0558                 <span class="comment">%    display(['optimal contracting ' ...</span>
0559                 <span class="comment">%             char(contract_dims{i})]);</span>
0560                 <span class="comment">%end</span>
0561             <span class="keyword">elseif</span>  ~strcmp( contract_type, <span class="string">'full'</span> )
0562                 contract_dims = obj.get_contraction_dims();
0563 
0564                 <span class="comment">%for i=1:length(contract_dims)</span>
0565                 <span class="comment">%    display(['contracting ' contract_dims(i).name]);</span>
0566                 <span class="comment">%end</span>
0567             <span class="keyword">end</span>
0568 
0569 
0570             extra_mem = 0;
0571             newmodel = obj;
0572 
0573             <span class="keyword">if</span> strcmp( contract_type, <span class="string">'full'</span>)
0574                 [ newmodel e_m ] = obj.contract_full(operation_type);
0575                 extra_mem = extra_mem + e_m;
0576             <span class="keyword">else</span>
0577                 <span class="keyword">for</span> i = 1:length(contract_dims)
0578                     [ newmodel e_m ]= <span class="keyword">...</span>
0579                         newmodel.contract(contract_dims(i), <span class="keyword">...</span>
0580                                           operation_type);
0581                     extra_mem = extra_mem + e_m;
0582                 <span class="keyword">end</span>
0583             <span class="keyword">end</span>
0584         <span class="keyword">end</span>
0585 
0586 
0587 
0588 
0589         <a name="_sub7" href="#_subfunctions" class="code">function [newmodel extra_mem] = contract_full(obj, operation_type)</a>
0590         <span class="comment">% generates a new full (temporary) tensor, multiplies all</span>
0591         <span class="comment">% latent tensors in to the full tensor and then</span>
0592         <span class="comment">% contracts full tensor over necessary indices and returns</span>
0593         <span class="comment">% newmodel with full_tensor in it</span>
0594 
0595             <span class="comment">% generate full tensor</span>
0596             F = <a href="TFFactor.html" class="code" title="">TFFactor</a>;
0597             F.name = <span class="string">'full_tensor'</span>;
0598             F.isTemp = 1;
0599             F.dims = obj.dims;    <span class="comment">% full indices</span>
0600 
0601             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0602                 <span class="comment">% generate global full_tensor_data</span>
0603                 <span class="keyword">global</span> full_tensor_data;
0604 
0605                 sz = <span class="string">''</span>;
0606                 <span class="keyword">for</span> adi = 1:length(obj.dims)
0607                     <span class="keyword">if</span> adi ~= 1
0608                         sz = [sz <span class="string">', '</span>];
0609                     <span class="keyword">end</span>
0610                     sz = [sz num2str(obj.dims(adi).cardinality) ];
0611                 <span class="keyword">end</span>
0612                 eval( [ <span class="string">' full_tensor_data = ones('</span> sz <span class="string">');'</span>] );
0613             <span class="keyword">end</span>
0614 
0615             extra_mem = F.get_element_size();
0616 
0617             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0618                 <span class="comment">% access global data of all latent factors</span>
0619                 lfi = obj.latent_factor_indices;
0620                 <span class="keyword">for</span> lfii = 1:length(lfi)
0621                     eval([<span class="string">'global '</span> <span class="keyword">...</span>
0622                           obj.factors(lfi(lfii)).get_data_name() <span class="keyword">...</span>
0623                          ]);
0624                 <span class="keyword">end</span>
0625 
0626                 <span class="comment">% multiply all latent tensors, store result in data_F</span>
0627                 <span class="keyword">for</span> lfii = 1:length(lfi)
0628                     <span class="comment">% following tensors should be multiplied with data_F</span>
0629                     eval([ <span class="string">'full_tensor_data = bsxfun(@times, full_tensor_data, '</span> <span class="keyword">...</span>
0630                            obj.factors(lfi(lfii)).get_data_name() <span class="string">');'</span> ]);
0631                 <span class="keyword">end</span>
0632 
0633                 <span class="comment">% contract necessary dimensions from full_tensor_data</span>
0634                 contract_dims = obj.get_contraction_dims();
0635                 <span class="keyword">for</span> cdi = 1:length(contract_dims)
0636                     full_tensor_data = sum( full_tensor_data,        <span class="keyword">...</span>
0637                                             obj.get_dimension_index( <span class="keyword">...</span>
0638                                                 contract_dims(cdi)) );
0639                 <span class="keyword">end</span>
0640             <span class="keyword">end</span>
0641 
0642             <span class="comment">% create and return a newmodel compatible with other</span>
0643             <span class="comment">% contract functions</span>
0644             newmodel = obj;
0645             newmodel.factors = [ obj.observed_factor F ];
0646         <span class="keyword">end</span>
0647 
0648 
0649 
0650 
0651         <a name="_sub8" href="#_subfunctions" class="code">function [newmodel extra_mem] = contract(obj, dim, operation_type)</a>
0652         <span class="comment">% returns a new TFModel generated by contracting obj with</span>
0653         <span class="comment">% dim which may add new temporary factors and mem_delta</span>
0654         <span class="comment">% integer value. extra_mem will be positive if a temporary</span>
0655         <span class="comment">% factor is generated and its value will indicate memory</span>
0656         <span class="comment">% usage of new factor. mem_delta will be zero if no</span>
0657         <span class="comment">% temporary factors are generated.</span>
0658         <span class="comment">% dim: TFDimension or char array or cell with the name of</span>
0659         <span class="comment">% the dimension</span>
0660         <span class="comment">% operation_type: if equals to 'compute' contraction is</span>
0661         <span class="comment">% calculated. if equals to 'mem_analysis' data elements are</span>
0662         <span class="comment">% not created.</span>
0663             extra_mem = 0;
0664 
0665             <span class="keyword">if</span> isa(dim, <span class="string">'TFDimension'</span>)
0666                 dim = dim.name;
0667             <span class="keyword">elseif</span> isa(dim, <span class="string">'cell'</span>)
0668                 dim = char(dim{1});
0669             <span class="keyword">elseif</span> ~isa(dim, <span class="string">'char'</span>)
0670                 display([<span class="string">'ERROR: unsupported dim type '</span> class(dim) <span class="keyword">...</span>
0671                          <span class="string">'was expecting TFDimension, cell or char '</span> <span class="keyword">...</span>
0672                          <span class="string">'array'</span>]);
0673                 <span class="keyword">return</span>
0674             <span class="keyword">end</span>
0675 
0676             newmodel = obj;
0677             newmodel.name = [obj.name <span class="string">'_'</span> dim];
0678 
0679             <span class="comment">% remove dim from the new model's factors'</span>
0680             contracted_factor_inds = [];
0681             <span class="keyword">for</span> f = 1:length(newmodel.factors)
0682                 <span class="keyword">if</span> ~newmodel.factors(f).isObserved
0683                     ind = <span class="keyword">...</span>
0684                         newmodel.factors(f).got_dimension(char(dim));
0685                     
0686                     <span class="keyword">if</span> ind ~= 0
0687                         <span class="comment">% remove this dimension from this factor</span>
0688                         newmodel.factors(f).dims(ind) = [];
0689 
0690                         contracted_factor_inds = <span class="keyword">...</span>
0691                             [ contracted_factor_inds f ];
0692                     <span class="keyword">end</span>
0693                 <span class="keyword">end</span>
0694             <span class="keyword">end</span>
0695 
0696             <span class="comment">% add a temporary factor including dimensions of</span>
0697             <span class="comment">% contracted factors other than contracted dimension</span>
0698             tmp=<a href="TFFactor.html" class="code" title="">TFFactor</a>;
0699             tmp.isTemp = 1;
0700             tmp.name = <span class="string">'tmp'</span>;
0701             names={};
0702             
0703             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0704                 <span class="comment">% for each dimension of the contracted factor</span>
0705                 <span class="keyword">for</span> cfi_dim = 1:length(newmodel.factors(contracted_factor_inds(cfii)).dims)
0706                     found=0;
0707                     <span class="keyword">for</span> ti = 1:length(tmp.dims)
0708                         <span class="keyword">if</span> tmp.dims(ti) == <span class="keyword">...</span>
0709                                 newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim)
0710                             found=1;
0711                             <span class="keyword">break</span>;
0712                         <span class="keyword">end</span>
0713                     <span class="keyword">end</span>
0714                     <span class="keyword">if</span> found == 0
0715                         tmp.dims = [tmp.dims <span class="keyword">...</span>
0716                                     newmodel.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0717                                     .dims(cfi_dim)];
0718                         names=[names <span class="keyword">...</span>
0719                               newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name];
0720                         <span class="comment">%display(['added from factor index' ...</span>
0721                         <span class="comment">%         contracted_factor_inds(cfii)])</span>
0722                         <span class="comment">%display(['added from factor' newmodel.factors(contracted_factor_inds(cfii)).name])</span>
0723                         <span class="comment">%display(['addd dim' char(newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name)])</span>
0724                     <span class="keyword">end</span>
0725                 <span class="keyword">end</span>
0726             <span class="keyword">end</span>
0727             names=unique(names);
0728             <span class="keyword">for</span> d = 1:length(names)
0729                 tmp.name = [tmp.name <span class="string">'_'</span> char(names(d))];
0730             <span class="keyword">end</span>
0731             tmp.name = [tmp.name <span class="string">'_minus_'</span> dim];
0732 
0733 
0734 
0735             <span class="keyword">if</span> strcmp( operation_type, <span class="string">'compute'</span> )
0736                 eval( [ <span class="string">'global '</span> tmp.get_data_name()  <span class="string">';'</span>] );
0737 
0738                 <span class="keyword">if</span> length(contracted_factor_inds) == 1
0739                     <span class="comment">% no multiplication</span>
0740                     eval( [ <span class="string">'global '</span> <span class="keyword">...</span>
0741                             obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0742                             .get_data_name() <span class="string">';'</span>] );
0743                     eval( [ tmp.get_data_name() <span class="string">' = '</span> <span class="keyword">...</span>
0744                             obj.factors(contracted_factor_inds(1)) <span class="keyword">...</span>
0745                             .get_data_name() <span class="string">';'</span>] );
0746                 <span class="keyword">else</span>
0747 
0748                     <span class="comment">% multiply first two into tmp data</span>
0749                     eval( [ <span class="string">'global'</span> <span class="keyword">...</span>
0750                             <span class="string">' '</span> obj.factors(contracted_factor_inds(1)).get_data_name() <span class="keyword">...</span>
0751                             <span class="string">' '</span> obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">';'</span>] );
0752 
0753                     eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0754                             obj.factors(contracted_factor_inds(1)).get_data_name() <span class="string">', '</span><span class="keyword">...</span>
0755                             obj.factors(contracted_factor_inds(2)).get_data_name() <span class="string">');'</span> <span class="keyword">...</span>
0756                           ] );
0757 
0758                     <span class="comment">% multiply tmp data with other factors</span>
0759                     <span class="keyword">for</span> cfii = 3:length(contracted_factor_inds)
0760                         eval( [ <span class="string">'global '</span><span class="keyword">...</span>
0761                                 obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0762                                 .get_data_name() <span class="string">';'</span>] );
0763                         eval( [ tmp.get_data_name() <span class="string">' = bsxfun (@times, '</span> <span class="keyword">...</span>
0764                                 tmp.get_data_name() <span class="string">','</span><span class="keyword">...</span>
0765                                 obj.factors(contracted_factor_inds(cfii)) <span class="keyword">...</span>
0766                                 .get_data_name() <span class="string">');'</span> ] );
0767                     <span class="keyword">end</span>
0768                 <span class="keyword">end</span>
0769 
0770 
0771                 <span class="comment">% sum contraction dimensions on tmp data</span>
0772                 
0773                 con_dim_index = obj.get_dimension_index(dim);
0774 
0775                 eval( [ tmp.get_data_name() <span class="string">' = sum( '</span> <span class="keyword">...</span>
0776                         tmp.get_data_name() <span class="string">', '</span> <span class="keyword">...</span>
0777                         num2str(con_dim_index) <span class="string">');'</span>] );
0778 
0779             <span class="keyword">end</span>
0780                
0781             newmodel.factors = [newmodel.factors tmp];
0782             extra_mem = tmp.get_element_size();
0783 
0784             <span class="comment">% remove contracted factors</span>
0785             <span class="comment">% other dimensions live within the tmp factor</span>
0786             removed_num=0; <span class="comment">% removal breaks loop index</span>
0787             <span class="keyword">for</span> cfii = 1:length(contracted_factor_inds)
0788                 newmodel.factors(contracted_factor_inds(cfii) <span class="keyword">...</span>
0789                                  - removed_num) = [];
0790                 removed_num = removed_num + 1;
0791             <span class="keyword">end</span>
0792         <span class="keyword">end</span>
0793 
0794 
0795 
0796 
0797         <a name="_sub9" href="#_subfunctions" class="code">function [ocs_dims] = get_optimal_contraction_sequence_dims(obj, </a><span class="keyword">...</span>
0798                                                               operation_type)
0799         <span class="comment">% Runs schedule_dp function to generate graph with least</span>
0800         <span class="comment">% memory using contraction sequence information in it. Then</span>
0801         <span class="comment">% searches TFGraph.optimal_edges for the optimal path and</span>
0802         <span class="comment">% returns a cell list of contraction dimension names.</span>
0803 
0804             <span class="keyword">global</span> ocs_cache;
0805 
0806             found = false;
0807             <span class="keyword">for</span> o = 1:length(ocs_cache)
0808                 <span class="keyword">if</span> ocs_cache(o).model == obj
0809                     found=true;
0810                     <span class="keyword">break</span>
0811                 <span class="keyword">end</span>
0812             <span class="keyword">end</span>
0813 
0814             <span class="keyword">if</span> found
0815                 <span class="comment">%display('cache hit')</span>
0816 
0817                 <span class="comment">%display([ 'ocs dims' ])</span>
0818                 ocs_dims = ocs_cache(o).ocs_dims;
0819                 <span class="comment">%for a =1:length(ocs_dims)</span>
0820                 <span class="comment">%    ocs_dims{a}</span>
0821                 <span class="comment">%end</span>
0822                 <span class="keyword">return</span>
0823             <span class="comment">%else</span>
0824             <span class="comment">%    display('cache miss')</span>
0825             <span class="keyword">end</span>
0826 
0827 
0828             graph = obj.schedule_dp(operation_type);
0829             t = graph.optimal_edges;
0830             t(t==0) = Inf;
0831             ocs_models = [];
0832             i = length(t);
0833             <span class="keyword">while</span> i ~= 1
0834                 ocs_models = [ ocs_models graph.node_list(i) ];
0835                 i = find( t(:,i) == min(t(:, i)) );
0836             <span class="keyword">end</span>
0837             ocs_models = [ ocs_models graph.node_list(i) ];
0838 
0839             ocs_dims = [];
0840             <span class="keyword">for</span> i = 1:(length(ocs_models)-1)
0841                 ocs_dims = [ ocs_dims <span class="keyword">...</span>
0842                              { setdiff( <span class="keyword">...</span>
0843                                  ocs_models(i)<span class="keyword">...</span>
0844                                  .get_current_contraction_dims, <span class="keyword">...</span>
0845                                  ocs_models(i+ <span class="keyword">...</span>
0846                                             1)<span class="keyword">...</span>
0847                                  .get_current_contraction_dims) }; <span class="keyword">...</span>
0848                            ];
0849             <span class="keyword">end</span>
0850 
0851             <span class="comment">%display([ 'cache store' ])</span>
0852             <span class="comment">%for a =1:length(ocs_dims)</span>
0853             <span class="comment">%    ocs_dims{a}</span>
0854             <span class="comment">%end</span>
0855             ocs_cache = [ ocs_cache <a href="TFOCSCache.html" class="code" title="">TFOCSCache</a>(obj, ocs_dims) ];
0856         <span class="keyword">end</span>
0857 
0858 
0859 
0860 
0861         <a name="_sub10" href="#_subfunctions" class="code">function [obj] = update_cost_from_latent(obj)</a>
0862             obj.cost = 0;
0863             lfi=obj.latent_factor_indices();
0864             <span class="keyword">for</span> fi = 1:length(lfi)
0865                 obj.cost = obj.cost + <span class="keyword">...</span>
0866                     obj.factors(lfi(fi)).get_element_size();
0867             <span class="keyword">end</span>
0868         <span class="keyword">end</span>
0869 
0870 
0871 
0872 
0873         <a name="_sub11" href="#_subfunctions" class="code">function [dn fn all_edges] = print_ubigraph(obj)</a>
0874         <span class="comment">% returns a string to be used by fgplot</span>
0875 
0876         <span class="comment">% add dimension nodes</span>
0877             dn = [ <span class="string">'[ '''</span> ];
0878             <span class="keyword">for</span> i =1:length(obj.dims)
0879                 <span class="keyword">if</span> i ~= 1
0880                     dn = [ dn <span class="string">''','''</span> ];
0881                 <span class="keyword">end</span>
0882                 dn = [ dn obj.dims(i).name ];
0883             <span class="keyword">end</span>
0884             dn = [ dn <span class="string">''' ] '</span> ];
0885 
0886             <span class="comment">% add factor nodes</span>
0887             fn = [ <span class="string">'[ '''</span> ];
0888             <span class="keyword">for</span> i =1:length(obj.factors)
0889                 <span class="keyword">if</span> i ~= 1
0890                     fn = [ fn <span class="string">''','''</span> ];
0891                 <span class="keyword">end</span>
0892                 fn = [ fn obj.factors(i).name ];
0893             <span class="keyword">end</span>
0894             fn = [ fn <span class="string">''' ] '</span> ];
0895 
0896             <span class="comment">% add edges</span>
0897             all_edges=[<span class="string">'[ '</span> ];
0898             <span class="keyword">for</span> d = 1:length(obj.dims)
0899                 <span class="keyword">if</span> d ~= 1
0900                     all_edges = [ all_edges <span class="string">' , '</span> ];
0901                 <span class="keyword">end</span>
0902 
0903                 edges=[<span class="string">'[ '</span> ];
0904 
0905                 <span class="comment">% include this dimension if a factor uses it</span>
0906                 <span class="keyword">for</span> f = 1:length(obj.factors)
0907                     <span class="keyword">for</span> fd = 1:length(obj.factors(f).dims)
0908                         <span class="keyword">if</span> obj.factors(f).dims(fd) == obj.dims(d)
0909                             <span class="keyword">if</span> length(edges) ~= 2
0910                                 edges = [ edges <span class="string">''','''</span> ];
0911                             <span class="keyword">else</span>
0912                                 edges = [ edges <span class="string">''''</span> ];
0913                             <span class="keyword">end</span>
0914                             edges = [ edges obj.factors(f).name ];
0915                         <span class="keyword">end</span>
0916                     <span class="keyword">end</span>
0917                 <span class="keyword">end</span>
0918 
0919                 all_edges = [ all_edges edges <span class="string">''' ]'</span> ];
0920             <span class="keyword">end</span>
0921             all_edges = [ all_edges <span class="string">' ]'</span> ];
0922         <span class="keyword">end</span>
0923 
0924 
0925 
0926 
0927         <a name="_sub12" href="#_subfunctions" class="code">function [size] = get_element_size(obj)</a>
0928         <span class="comment">% returns number of elements for this model</span>
0929             size=0;
0930             <span class="keyword">for</span> f = 1:length(obj.factors)
0931                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0932                     size = size + <span class="keyword">...</span>
0933                            obj.factors(f).get_element_size();
0934                 <span class="keyword">end</span>
0935             <span class="keyword">end</span>
0936         <span class="keyword">end</span>
0937 
0938 
0939 
0940 
0941         <a name="_sub13" href="#_subfunctions" class="code">function [card] = get_index_card(obj, index_char)</a>
0942         <span class="comment">% returns cardinality of a given name of a dimension</span>
0943             <span class="keyword">for</span> d = 1:length(obj.dims)
0944                 <span class="keyword">if</span> obj.dims(d).name == index_char
0945                     card = obj.dims(d).cardinality;
0946                     <span class="keyword">break</span>
0947                 <span class="keyword">end</span>
0948             <span class="keyword">end</span>
0949         <span class="keyword">end</span>
0950 
0951 
0952 
0953 
0954         <a name="_sub14" href="#_subfunctions" class="code">function [factor] = get_first_non_observed_factor(obj)</a>
0955         <span class="comment">% returns first non observed factor index, used to return</span>
0956         <span class="comment">% index of the output factor when all latent factors are</span>
0957         <span class="comment">% contracted out. in this case only output (observed) and a</span>
0958         <span class="comment">% single temporary non-observed factors should be present</span>
0959         <span class="comment">% in the model (ie fully contracted model).</span>
0960             <span class="keyword">for</span> f = 1:length(obj.factors)
0961                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0962                     factor = obj.factors(f);
0963                     <span class="keyword">return</span>
0964                 <span class="keyword">end</span>
0965             <span class="keyword">end</span>
0966         <span class="keyword">end</span>
0967 
0968 
0969 
0970 
0971         <a name="_sub15" href="#_subfunctions" class="code">function [ind] = get_first_non_observed_factor_index(obj)</a>
0972         <span class="comment">% returns first non observed factor index, used to return</span>
0973         <span class="comment">% index of the output factor</span>
0974             <span class="keyword">for</span> f = 1:length(obj.factors)
0975                 <span class="keyword">if</span> obj.factors(f).isObserved == 0
0976                     ind = f;
0977                     <span class="keyword">return</span>
0978                 <span class="keyword">end</span>
0979             <span class="keyword">end</span>
0980         <span class="keyword">end</span>
0981 
0982 
0983 
0984 
0985         <a name="_sub16" href="#_subfunctions" class="code">function [ind] = find_cell_char(obj, chars)</a>
0986         <span class="comment">% returns index of a given char array in object's dimension array</span>
0987             <span class="keyword">for</span> ind=1:length(obj.dims)
0988                 <span class="keyword">if</span> obj.dims(ind).name == chars
0989                     <span class="keyword">return</span>
0990                 <span class="keyword">end</span>
0991             <span class="keyword">end</span>
0992             ind=0;
0993         <span class="keyword">end</span>
0994 
0995 
0996 
0997 
0998        <a name="_sub17" href="#_subfunctions" class="code">function [r] = get_dimension_index(obj, dim)</a>
0999         <span class="comment">% returns index of dimension dim in obj.dims if obj</span>
1000         <span class="comment">% contains TFDimension (or char) dim returns 0 otherwise</span>
1001 
1002             r=0;
1003             <span class="keyword">for</span> d = 1:length(obj.dims)
1004                 <span class="keyword">if</span> obj.dims(d) == dim
1005                     r=d;
1006                     <span class="keyword">break</span>;
1007                 <span class="keyword">end</span>
1008             <span class="keyword">end</span>           
1009        <span class="keyword">end</span>
1010 
1011 
1012 
1013 
1014        <a name="_sub18" href="#_subfunctions" class="code">function [ordered_index_chars] = order_dims(obj, </a><span class="keyword">...</span>
1015                                                     dims_array)
1016             <span class="comment">% order given cell of dimension names according to</span>
1017             <span class="comment">% factor.dims order</span>
1018 
1019             tmp=cell(length(dims_array), 3);
1020 
1021             tmp(:,1) = dims_array;
1022             <span class="keyword">for</span> i = 1:length(dims_array)
1023                 tmp{i,2} = obj.get_index_card(char(dims_array(i)));
1024                 tmp{i,3} = obj.find_cell_char(char(dims_array(i))); <span class="comment">% order of the index</span>
1025                                                                     <span class="comment">% in the model</span>
1026             <span class="keyword">end</span>
1027 
1028             tmp=sortrows(tmp,3); <span class="comment">% sort by the order of the model indices</span>
1029             ordered_index_chars=tmp(:,1)';
1030         <span class="keyword">end</span>
1031 
1032 
1033 
1034 
1035         <a name="_sub19" href="#_subfunctions" class="code">function [contract_dims] = get_contraction_dims(obj)</a>
1036         <span class="comment">% returns cell of dimensions which must be contracted to</span>
1037         <span class="comment">% calculate output factor(s)</span>
1038 
1039             output_chars = {};
1040             <span class="keyword">for</span> f=1:length(obj.factors)
1041                 <span class="keyword">if</span> obj.factors(f).isObserved
1042 
1043                     <span class="comment">% for each dimension of this factor</span>
1044                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
1045                         output_chars = [output_chars <span class="keyword">...</span>
1046                                         obj.factors(f).dims(i).name];
1047                     <span class="keyword">end</span>
1048 
1049                 <span class="keyword">end</span>
1050             <span class="keyword">end</span>
1051 
1052             <span class="comment">% contraction dimensions: alldims - output_dims</span>
1053             contract_dims={};
1054             <span class="keyword">for</span> d_a = 1:length(obj.dims)
1055                 found=0;
1056                 <span class="keyword">for</span> d_o = 1:length(output_chars)
1057                     <span class="keyword">if</span> obj.dims(d_a) == char(output_chars(d_o))
1058                         found=1;
1059                         <span class="keyword">break</span>
1060                     <span class="keyword">end</span>
1061                 <span class="keyword">end</span>
1062 
1063                 <span class="keyword">if</span> found == 0
1064                     contract_dims = [contract_dims obj.dims(d_a)];
1065                     <span class="comment">%['add '  obj.dims(d_a).name]</span>
1066                 <span class="keyword">end</span>
1067             <span class="keyword">end</span>
1068 
1069             <span class="comment">%['return ' contract_dims.name]</span>
1070             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
1071         <span class="keyword">end</span>
1072 
1073 
1074 
1075 
1076         <a name="_sub20" href="#_subfunctions" class="code">function [contract_dims] = get_current_contraction_dims(obj)</a>
1077         <span class="comment">% returns cell of TFDimensions which must be contracted to</span>
1078         <span class="comment">% calculate output factor(s) by using current factors to</span>
1079         <span class="comment">% calculate all dimension not model.dims. (model.dims is always</span>
1080         <span class="comment">% fixed to maximum possible dimension list.)</span>
1081 
1082             output_chars = {};
1083             <span class="keyword">for</span> f=1:length(obj.factors)
1084                 <span class="keyword">if</span> obj.factors(f).isObserved
1085 
1086                     <span class="comment">% for each dimension of this factor</span>
1087                     <span class="keyword">for</span> i=1:length(obj.factors(f).dims)
1088                         output_chars = [output_chars <span class="keyword">...</span>
1089                                         obj.factors(f).dims(i).name];
1090                     <span class="keyword">end</span>
1091 
1092                 <span class="keyword">end</span>
1093             <span class="keyword">end</span>
1094 
1095             <span class="comment">% contraction dimensions: alldims - output_dims</span>
1096             alldims={};
1097             <span class="keyword">for</span> f = 1:length(obj.factors)
1098                 <span class="keyword">for</span> d = 1:length(obj.factors(f).dims)
1099                     found = 0;
1100                     n=obj.factors(f).dims(d).name;
1101                     <span class="keyword">for</span> i=1:length(alldims)
1102                         <span class="keyword">if</span> char(alldims(i)) == n
1103                             found = 1;
1104                             <span class="keyword">break</span>
1105                         <span class="keyword">end</span>
1106                     <span class="keyword">end</span>
1107 
1108                     <span class="keyword">if</span> ~found
1109                         alldims = [alldims n];
1110                     <span class="keyword">end</span>
1111                 <span class="keyword">end</span>
1112             <span class="keyword">end</span>
1113 
1114             contract_dims={};
1115             <span class="keyword">for</span> d_a = 1:length(alldims)
1116                 found=0;
1117                 <span class="keyword">for</span> d_o = 1:length(output_chars)
1118                     <span class="keyword">if</span> char(alldims(d_a)) == char(output_chars(d_o))
1119                         found=1;
1120                         <span class="keyword">break</span>
1121                     <span class="keyword">end</span>
1122                 <span class="keyword">end</span>
1123 
1124                 <span class="keyword">if</span> found == 0
1125                     contract_dims = [contract_dims alldims(d_a)];
1126                     <span class="comment">%['add '  alldims(d_a).name]</span>
1127                 <span class="keyword">end</span>
1128             <span class="keyword">end</span>
1129 
1130             <span class="comment">%['return ' contract_dims.name]</span>
1131             <span class="comment">%contract_dims = obj.order_dims(unique(contract_dims));</span>
1132         <span class="keyword">end</span>
1133 
1134 
1135 
1136 
1137         <a name="_sub21" href="#_subfunctions" class="code">function [factor_inds] = latent_factor_indices(obj)</a>
1138             factor_inds=[];
1139             <span class="keyword">for</span> f=1:length(obj.factors)
1140                 <span class="keyword">if</span> obj.factors(f).isLatent
1141                     factor_inds = [ factor_inds f ];
1142                 <span class="keyword">end</span>
1143             <span class="keyword">end</span>
1144         <span class="keyword">end</span>
1145 
1146 
1147 
1148 
1149         <a name="_sub22" href="#_subfunctions" class="code">function [factors] = latent_factors(obj)</a>
1150             factors=[];
1151             <span class="keyword">for</span> f=1:length(obj.factors)
1152                 <span class="keyword">if</span> obj.factors(f).isLatent
1153                     factors = [ factors obj.factors(f) ];
1154                 <span class="keyword">end</span>
1155             <span class="keyword">end</span>
1156         <span class="keyword">end</span>
1157 
1158 
1159 
1160 
1161         <a name="_sub23" href="#_subfunctions" class="code">function [factor_ind] = observed_factor_index(obj)</a>
1162             factor_ind=0;
1163             <span class="keyword">for</span> f=1:length(obj.factors)
1164                 <span class="keyword">if</span> obj.factors(f).isObserved
1165                     factor_ind = f;
1166                     <span class="keyword">return</span>
1167                 <span class="keyword">end</span>
1168             <span class="keyword">end</span>
1169         <span class="keyword">end</span>
1170 
1171 
1172 
1173 
1174         <a name="_sub24" href="#_subfunctions" class="code">function [factor] = observed_factor(obj)</a>
1175         <span class="comment">% returns first observed factor (useful for PLTF operations)</span>
1176             <span class="keyword">for</span> f=1:length(obj.factors)
1177                 <span class="keyword">if</span> obj.factors(f).isObserved
1178                     factor = obj.factors(f);
1179                     <span class="keyword">return</span>
1180                 <span class="keyword">end</span>
1181             <span class="keyword">end</span>
1182         <span class="keyword">end</span>
1183 
1184 
1185 
1186 
1187         <a name="_sub25" href="#_subfunctions" class="code">function [factors] = observed_factors(obj)</a>
1188             factors=[];
1189             <span class="keyword">for</span> f=1:length(obj.factors)
1190                 <span class="keyword">if</span> obj.factors(f).isObserved
1191                     factors = [ factors obj.factors(f) ];
1192                 <span class="keyword">end</span>
1193             <span class="keyword">end</span>
1194         <span class="keyword">end</span>
1195 
1196 
1197 
1198 
1199         <a name="_sub26" href="#_subfunctions" class="code">function [factors] = input_factors(obj)</a>
1200             factors=[];
1201             <span class="keyword">for</span> f=1:length(obj.factors)
1202                 <span class="keyword">if</span> obj.factors(f).isInput
1203                     factors = [ factors obj.factors(f) ];
1204                 <span class="keyword">end</span>
1205             <span class="keyword">end</span>
1206         <span class="keyword">end</span>
1207 
1208 
1209 
1210 
1211         <a name="_sub27" href="#_subfunctions" class="code">function [factors] = temp_factors(obj)</a>
1212             factors=[];
1213             <span class="keyword">for</span> f=1:length(obj.factors)
1214                 <span class="keyword">if</span> obj.factors(f).isTemp
1215                     factors = [ factors obj.factors(f) ];
1216                 <span class="keyword">end</span>
1217             <span class="keyword">end</span>
1218         <span class="keyword">end</span>
1219 
1220 
1221 
1222 
1223         <a name="_sub28" href="#_subfunctions" class="code">function [] = rand_init_latent_factors(obj, type, imax)</a>
1224 
1225             <span class="keyword">if</span> ~strcmp(type, <span class="string">'all'</span>) &amp;&amp; ~strcmp(type, <span class="string">'nonClamped'</span>)
1226                 throw(MException(<span class="string">'TFModel:WrongInitType'</span>, <span class="keyword">...</span>
1227                                  [<span class="string">'Supported init type values: all, '</span> <span class="keyword">...</span>
1228                                   <span class="string">'nonClamped'</span>]));
1229             <span class="keyword">end</span>
1230 
1231             <span class="keyword">for</span> fi=1:length(obj.latent_factor_indices)
1232 
1233                 <span class="keyword">if</span> strcmp(type, <span class="string">'all'</span>) || <span class="keyword">...</span>
1234                         ( strcmp(type, <span class="string">'nonClamped'</span>) &amp;&amp; <span class="keyword">...</span>
1235                           obj.factors(fi).isInput == 0 )
1236                     
1237                     <span class="keyword">if</span> nargin==2
1238                         obj.factors(fi).rand_init(obj.dims);
1239                     <span class="keyword">else</span>
1240                         obj.factors(fi).rand_init(obj.dims, imax);
1241                     <span class="keyword">end</span>
1242 
1243                 <span class="keyword">end</span>
1244             <span class="keyword">end</span>
1245 
1246         <span class="keyword">end</span>
1247 
1248 
1249         
1250         <a name="_sub29" href="#_subfunctions" class="code">function [r] = eq(a,b)</a>
1251             r = false;
1252 
1253             <span class="comment">% mark matched b factors</span>
1254             <span class="comment">% if there are any unmarked -&gt; inequal</span>
1255             <span class="comment">% problematic case:</span>
1256             <span class="comment">% a.factors ( ip, jpi ) , b.factors (  ip, pi )</span>
1257             <span class="comment">% b==a matches all b objects with a.factors(1)</span>
1258             <span class="comment">% but a~=b !</span>
1259 
1260             b_marks = zeros(size(b.factors));
1261 
1262             <span class="keyword">if</span> length(a.factors) == length(b.factors)
1263                 <span class="keyword">for</span> f_a = 1:length(a.factors)
1264                     found = 0;
1265                     <span class="keyword">for</span> f_b = 1:length(b.factors)
1266                         <span class="keyword">if</span> a.factors(f_a) == b.factors(f_b) &amp;&amp; <span class="keyword">...</span>
1267                                 b_marks(f_b) == 0
1268                             found = 1;
1269                             b_marks(f_b) = 1;
1270                             <span class="keyword">break</span>
1271                         <span class="keyword">end</span>
1272                     <span class="keyword">end</span>
1273 
1274                     <span class="keyword">if</span> found == 0
1275                         <span class="keyword">return</span>
1276                     <span class="keyword">end</span>
1277                 <span class="keyword">end</span>
1278 
1279                 r = true;
1280             <span class="keyword">end</span>
1281         <span class="keyword">end</span>
1282 
1283 
1284 
1285 
1286         <a name="_sub30" href="#_subfunctions" class="code">function [uncontraction_dims] = get_uncontraction_dims(obj)</a>
1287         <span class="comment">% returns list of TFDimension objects representing</span>
1288         <span class="comment">% dimensions which are required to be added to the current</span>
1289         <span class="comment">% TFModel object in order to reach initial model where</span>
1290         <span class="comment">% uncontraction_dims = {}</span>
1291         <span class="comment">% Calculation is performed as follows:</span>
1292         <span class="comment">% uncontraction_dims = contraction_dims - current_contraction_dims</span>
1293 
1294             contraction_dims = obj.get_contraction_dims();
1295             current_contraction_dims = <span class="keyword">...</span>
1296                 obj.get_current_contraction_dims();
1297             uncontraction_dims = [];
1298 
1299             <span class="keyword">for</span> cdi = 1:length(contraction_dims)
1300                 found=0;
1301                 <span class="keyword">for</span> ccdi = 1:length(current_contraction_dims)
1302                     <span class="keyword">if</span> contraction_dims(cdi) == <span class="keyword">...</span>
1303                             char(current_contraction_dims(ccdi))
1304                         found=1;
1305                         <span class="keyword">break</span>;
1306                     <span class="keyword">end</span>
1307                 <span class="keyword">end</span>
1308                 <span class="keyword">if</span> ~found
1309                     uncontraction_dims = [ uncontraction_dims <span class="keyword">...</span>
1310                                         contraction_dims(cdi) ];
1311                 <span class="keyword">end</span>
1312             <span class="keyword">end</span>
1313         <span class="keyword">end</span>
1314 
1315 
1316     <span class="keyword">end</span>
1317 
1318 
1319 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 16-Aug-2012 20:47:03 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34148766-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
