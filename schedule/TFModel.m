classdef TFModel
% Class representing data required to describe a tensor
% factorization model

    properties
        name='';    % name of the model
        factors=[]; % array of TFFactor



        dims=[];    % array of TFDimension used by factors defines
                    % order of dimensions on memory


        tree_index = 0; % index of current model in externally
                        % stored model list

        parent_tree_indices=[]; % array of integers representing
                                % indices of parents of this
                                % model. list of models are assumed
                                % to be stored externally
        children_tree_indices=[];
        cost=0;
    end

    methods

        function [hat_X] = pltf(obj, iternum, contraction_order)
        % performs PLTF update operations on the model
        % returns estimated TFFactor (\hat(X))
        % iternum: number of iterations
        % contraction_order: array of TFDimension, if specified
        % defines order of contraction operations

            hat_X = obj.observed_factor;
            hat_X.data = rand(size(hat_X.data));

            for alpha=1:length(obj.latent_factor_indices)
                obj.factors(alpha).data = ...
                    obj.factors(alpha).data  .* ...
                    obj.delta(alpha, obj.observed_factor(obj.observed_factor) ./ ...
                              hat_X, contraction_order)  ./ ...
                    obj.delta(alpha, ones(size(hat_X.data)), contraction_order);
            end
        end

        function [] = delta(obj, alpha, A, contraction_order)
        % PLTF delta function implementation
        % alpha: index of latent factor in TFModel.factors array
        % which will be updated
        % A: operand element of delta function
        % contraction_order: array of TFDimension defines order of
        % contraction operations

            for c = 1:length(contraction_order)
                % for each contraction dimension
                %   find latent and temporary factors using this
                %   dimension perform multiplication and
                %   contraction with these elements and delta
                %   operand factor A, generating any necessary
                %   temporary factors
                
                
            end
            
        end

        function [r] = eq(a,b)
            r = logical(0);

            if length(a.factors) == length(b.factors)
                for f_a = 1:length(a.factors)
                    found = 0;
                    for f_b = 1:length(b.factors)
                        if a.factors(f_a) == b.factors(f_b)
                            found = 1;
                            break
                        end
                    end

                    if found == 0
                        return
                    end
                end

                r = logical(1);
            end
        end

        function [newmodel] = contract(obj, dim)
        % returns a new TFModel generated by contracting obj with
        % dim which may add new temporary factors. 
        % dim: TFDimension or char array or cell with the name of
        % the dimension

            if isa(dim, 'TFDimension')
                dim = dim.name
            elseif isa(dim, 'char') || isa(dim, 'cell')
                dim = char(dim);
            else
                display(['ERROR: unsupported dim type ' class(dim) ...
                         'was expecting TFDimension, cell or char ' ...
                         'array']);
                return
            end

            newmodel = obj;
            newmodel.name = [obj.name '_' dim];

            % remove dim from the new model's factors'
            contracted_factor_inds = [];
            for f = 1:length(newmodel.factors)
                if ~newmodel.factors(f).isObserved
                    ind = ...
                        newmodel.factors(f).got_dimension(char(dim));
                    
                    if ind ~= 0
                        % remove this dimension from this factor
                        newmodel.factors(f).dims(ind) = [];

                        contracted_factor_inds = ...
                            [ contracted_factor_inds f ];
                    end
                end
            end

            % add a temporary factor including dimensions of
            % contracted factors other than contracted dimension
            tmp=TFFactor;
            tmp.isTemp = 1;
            tmp.name = 'tmp';
            name={};
            for cfii = 1:length(contracted_factor_inds)
                % for each dimension of the contracted factor
                for cfi_dim = 1:length(newmodel.factors(contracted_factor_inds(cfii)).dims)
                    found=0;
                    for ti = 1:length(tmp.dims)
                        if tmp.dims(ti) == ...
                                newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim)
                            found=1;
                            break;
                        end
                    end
                    if found == 0
                        tmp.dims = [tmp.dims ...
                                    newmodel.factors(contracted_factor_inds(cfii)) ...
                                    .dims(cfi_dim)];
                        name=[name ...
                              newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name];
                        %display(['added from factor index' ...
                        %         contracted_factor_inds(cfii)])
                        %display(['added from factor' newmodel.factors(contracted_factor_inds(cfii)).name])
                        %display(['addd dim' char(newmodel.factors(contracted_factor_inds(cfii)).dims(cfi_dim).name)])
                    end
                end
            end
            name=unique(name);
            for d = 1:length(name)
                tmp.name = [tmp.name '_' char(name(d))];
            end
            tmp.name = [tmp.name '_minus_' dim];
            newmodel.factors = [newmodel.factors tmp];


            % remove dim from newmodel's dims array
            newdims=[];
            for d = 1:length(newmodel.dims)
                if newmodel.dims(d) == char(dim)
                else
                    newdims = [ newdims newmodel.dims(d) ];
                end
            end
            newmodel.dims = newdims;


            % remove contracted factors
            % other dimensions live within the tmp factor
            removed_num=0; % removal breaks loop index
            for cfii = 1:length(contracted_factor_inds)
                newmodel.factors(contracted_factor_inds(cfii) ...
                                 - removed_num) = [];
                removed_num = removed_num + 1;
            end
        end


        function [dn fn all_edges] = print(obj)
        % returns a string to be used by fgplot

        % add dimension nodes
            dn = [ '[ ''' ];
            for i =1:length(obj.dims)
                if i ~= 1
                    dn = [ dn ''',''' ];
                end
                dn = [ dn obj.dims(i).name ];
            end
            dn = [ dn ''' ] ' ];

            % add factor nodes
            fn = [ '[ ''' ];
            for i =1:length(obj.factors)
                if i ~= 1
                    fn = [ fn ''',''' ];
                end
                fn = [ fn obj.factors(i).name ];
            end
            fn = [ fn ''' ] ' ];

            % add edges
            all_edges=['[ ' ];
            for d = 1:length(obj.dims)
                if d ~= 1
                    all_edges = [ all_edges ' , ' ];
                end

                edges=['[ ' ];

                % include this dimension if a factor uses it
                for f = 1:length(obj.factors)
                    for fd = 1:length(obj.factors(f).dims)
                        if obj.factors(f).dims(fd) == obj.dims(d)
                            if length(edges) ~= 2
                                edges = [ edges ''',''' ];
                            else
                                edges = [ edges '''' ];
                            end
                            edges = [ edges obj.factors(f).name ];
                        end
                    end
                end

                all_edges = [ all_edges edges ''' ]' ];
            end
            all_edges = [ all_edges ' ]' ]
        end

        function [size] = get_element_size(obj)
        % returns number of elements for this model
            size=0;
            for f = 1:length(obj.factors)
                if obj.factors(f).isObserved == 0
                    size = size + ...
                           obj.factors(f).get_element_size();
                end
            end
        end

        function [card] = get_index_card(obj, index_char)
        % returns cardinality of a given name of a dimension
            for d = 1:length(obj.dims)
                if obj.dims(d).name == index_char
                    card = obj.dims(d).cardinality;
                    break
                end
            end
        end


        function [ind] = find_cell_char(obj, chars)
        % returns index of a given char array in object's dimension array
            for ind=1:length(obj.dims)
                if obj.dims(ind).name == chars
                    return
                end
            end
            ind=0
        end

        function [ordered_index_chars] = order_dims(obj, ...
                                                    dims_array)
            % order given cell of dimension names according to
            % factor.dims order

            dims_array

            tmp=cell(length(dims_array), 3);

            tmp(:,1) = dims_array;
            for i = 1:length(dims_array)
                tmp{i,2} = obj.get_index_card(char(dims_array(i)));
                tmp{i,3} = obj.find_cell_char(char(dims_array(i))); % order of the index
                                                                    % in the model
            end

            tmp=sortrows(tmp,3); % sort by the order of the model indices
            ordered_index_chars=tmp(:,1)';
        end


        function [contract_dims] = get_contraction_dims(obj)
        % returns cell of dimensions which must be contracted to
        % calculate output factor(s)

            output_chars = {};
            for f=1:length(obj.factors)
                if obj.factors(f).isObserved

                    % for each dimension of this factor
                    for i=1:length(obj.factors(f).dims)
                        output_chars = [output_chars ...
                                        obj.factors(f).dims(i).name];
                    end

                end
            end

            % contraction dimensions: alldims - output_dims
            contract_dims={};
            for d_a = 1:length(obj.dims)
                found=0;
                for d_o = 1:length(output_chars)
                    if obj.dims(d_a) == char(output_chars(d_o))
                        found=1;
                        break
                    end
                end

                if found == 0
                    contract_dims = [contract_dims obj.dims(d_a)];
                end
            end

            %contract_dims = obj.order_dims(unique(contract_dims));
        end

        function [factor_inds] = latent_factor_indices(obj)
            factor_inds=[]
            for f=1:length(obj.factors)
                if obj.factors(f).isLatent
                    factor_inds = [ factor_inds f ]
                end
            end
        end


        function [factors] = latent_factors(obj)
            factors=[]
            for f=1:length(obj.factors)
                if obj.factors(f).isLatent
                    factors = [ factors obj.factors(f) ]
                end
            end
        end

        function [factor] = observed_factor(obj)
        % returns first observed factor (useful for PLTF operations)
            factor
            for f=1:length(obj.factors)
                if obj.factors(f).isObserved
                    factor = obj.factors(f)
                    return
                end
            end
        end

        function [factors] = observed_factors(obj)
            factors=[]
            for f=1:length(obj.factors)
                if obj.factors(f).isObserved
                    factors = [ factors obj.factors(f) ]
                end
            end
        end

        function [factors] = input_factors(obj)
            factors=[]
            for f=1:length(obj.factors)
                if obj.factors(f).isInput
                    factors = [ factors obj.factors(f) ]
                end
            end
        end

        function [factors] = temp_factors(obj)
            factors=[]
            for f=1:length(obj.factors)
                if obj.factors(f).isTemp
                    factors = [ factors obj.factors(f) ]
                end
            end
        end

    end

end